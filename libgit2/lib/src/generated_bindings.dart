// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for libgit2
class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Query compile time options for libgit2.
  ///
  /// @return A combination of GIT_FEATURE_* values.
  ///
  /// - GIT_FEATURE_THREADS
  /// Libgit2 was compiled with thread support. Note that thread support is
  /// still to be seen as a 'work in progress' - basic object lookups are
  /// believed to be threadsafe, but other operations may not be.
  ///
  /// - GIT_FEATURE_HTTPS
  /// Libgit2 supports the https:// protocol. This requires the openssl
  /// library to be found when compiling libgit2.
  ///
  /// - GIT_FEATURE_SSH
  /// Libgit2 supports the SSH protocol for network operations. This requires
  /// the libssh2 library to be found when compiling libgit2
  int libgit2_features() {
    return _libgit2_features();
  }

  late final _libgit2_featuresPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('git_libgit2_features');
  late final _libgit2_features =
      _libgit2_featuresPtr.asFunction<int Function()>();

  /// Free the memory referred to by the git_buf.
  ///
  /// Note that this does not free the `git_buf` itself, just the memory
  /// pointed to by `buffer->ptr`.  This will not free the memory if it looks
  /// like it was not allocated internally, but it will clear the buffer back
  /// to the empty state.
  ///
  /// @param buffer The buffer to deallocate
  void buf_dispose(
    ffi.Pointer<git_buf> buffer,
  ) {
    return _buf_dispose(
      buffer,
    );
  }

  late final _buf_disposePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_buf>)>>(
          'git_buf_dispose');
  late final _buf_dispose =
      _buf_disposePtr.asFunction<void Function(ffi.Pointer<git_buf>)>();

  /// Copy an oid from one structure to another.
  ///
  /// @param out oid structure the result is written into.
  /// @param src oid structure to copy from.
  /// @return 0 on success or error code
  int oid_cpy(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_oid> src,
  ) {
    return _oid_cpy(
      out,
      src,
    );
  }

  late final _oid_cpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>>('git_oid_cpy');
  late final _oid_cpy = _oid_cpyPtr
      .asFunction<int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>();

  /// Open a git repository.
  ///
  /// The 'path' argument must point to either a git repository
  /// folder, or an existing work dir.
  ///
  /// The method will automatically detect if 'path' is a normal
  /// or bare repository or fail is 'path' is neither.
  ///
  /// @param out pointer to the repo which will be opened
  /// @param path the path to the repository
  /// @return 0 or an error code
  int repository_open(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _repository_open(
      out,
      path,
    );
  }

  late final _repository_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<ffi.Int8>)>>('git_repository_open');
  late final _repository_open = _repository_openPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_repository>>, ffi.Pointer<ffi.Int8>)>();

  /// Free a previously allocated repository
  ///
  /// Note that after a repository is free'd, all the objects it has spawned
  /// will still exist until they are manually closed by the user
  /// with `git_object_free`, but accessing any of the attributes of
  /// an object without a backing repository will result in undefined
  /// behavior
  ///
  /// @param repo repository handle to close. If NULL nothing occurs.
  void repository_free(
    ffi.Pointer<git_repository> repo,
  ) {
    return _repository_free(
      repo,
    );
  }

  late final _repository_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_repository>)>>(
      'git_repository_free');
  late final _repository_free = _repository_freePtr
      .asFunction<void Function(ffi.Pointer<git_repository>)>();

  /// Creates a new Git repository in the given folder.
  ///
  /// TODO:
  /// - Reinit the repository
  ///
  /// @param out pointer to the repo which will be created or reinitialized
  /// @param path the path to the repository
  /// @param is_bare if true, a Git repository without a working directory is
  /// created at the pointed path. If false, provided path will be
  /// considered as the working directory into which the .git directory
  /// will be created.
  ///
  /// @return 0 or an error code
  int repository_init(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> path,
    int is_bare,
  ) {
    return _repository_init(
      out,
      path,
      is_bare,
    );
  }

  late final _repository_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<ffi.Int8>, ffi.Uint32)>>('git_repository_init');
  late final _repository_init = _repository_initPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<ffi.Int8>, int)>();

  /// Initialize git_repository_init_options structure
  ///
  /// Initializes a `git_repository_init_options` with default values. Equivalent to
  /// creating an instance with `GIT_REPOSITORY_INIT_OPTIONS_INIT`.
  ///
  /// @param opts The `git_repository_init_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REPOSITORY_INIT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int repository_init_options_init(
    ffi.Pointer<git_repository_init_options> opts,
    int version,
  ) {
    return _repository_init_options_init(
      opts,
      version,
    );
  }

  late final _repository_init_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<git_repository_init_options>,
              ffi.Uint32)>>('git_repository_init_options_init');
  late final _repository_init_options_init =
      _repository_init_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_repository_init_options>, int)>();

  /// Create a new Git repository in the given folder with extended controls.
  ///
  /// This will initialize a new git repository (creating the repo_path
  /// if requested by flags) and working directory as needed.  It will
  /// auto-detect the case sensitivity of the file system and if the
  /// file system supports file mode bits correctly.
  ///
  /// @param out Pointer to the repo which will be created or reinitialized.
  /// @param repo_path The path to the repository.
  /// @param opts Pointer to git_repository_init_options struct.
  /// @return 0 or an error code on failure.
  int repository_init_ext(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> repo_path,
    ffi.Pointer<git_repository_init_options> opts,
  ) {
    return _repository_init_ext(
      out,
      repo_path,
      opts,
    );
  }

  late final _repository_init_extPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int32 Function(
                  ffi.Pointer<ffi.Pointer<git_repository>>,
                  ffi.Pointer<ffi.Int8>,
                  ffi.Pointer<git_repository_init_options>)>>(
      'git_repository_init_ext');
  late final _repository_init_ext = _repository_init_extPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<ffi.Int8>, ffi.Pointer<git_repository_init_options>)>();

  /// Retrieve and resolve the reference pointed at by HEAD.
  ///
  /// The returned `git_reference` will be owned by caller and
  /// `git_reference_free()` must be called when done with it to release the
  /// allocated memory and prevent a leak.
  ///
  /// @param out pointer to the reference which will be retrieved
  /// @param repo a repository object
  ///
  /// @return 0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing
  /// branch, GIT_ENOTFOUND when HEAD is missing; an error code otherwise
  int repository_head(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _repository_head(
      out,
      repo,
    );
  }

  late final _repository_headPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>)>>('git_repository_head');
  late final _repository_head = _repository_headPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>)>();

  /// Check if the current branch is unborn
  ///
  /// An unborn branch is one named from HEAD but which doesn't exist in
  /// the refs namespace, because it doesn't have any commit to point to.
  ///
  /// @param repo Repo to test
  /// @return 1 if the current branch is unborn, 0 if it's not; error
  /// code if there was an error
  int repository_head_unborn(
    ffi.Pointer<git_repository> repo,
  ) {
    return _repository_head_unborn(
      repo,
    );
  }

  late final _repository_head_unbornPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<git_repository>)>>(
      'git_repository_head_unborn');
  late final _repository_head_unborn = _repository_head_unbornPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Get the Index file for this repository.
  ///
  /// If a custom index has not been set, the default
  /// index for the repository will be returned (the one
  /// located in `.git/index`).
  ///
  /// The index must be freed once it's no longer being used by
  /// the user.
  ///
  /// @param out Pointer to store the loaded index
  /// @param repo A repository object
  /// @return 0, or an error code
  int repository_index(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _repository_index(
      out,
      repo,
    );
  }

  late final _repository_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<git_repository>)>>('git_repository_index');
  late final _repository_index = _repository_indexPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index>>, ffi.Pointer<git_repository>)>();

  /// Remove all the metadata associated with an ongoing command like merge,
  /// revert, cherry-pick, etc.  For example: MERGE_HEAD, MERGE_MSG, etc.
  ///
  /// @param repo A repository object
  /// @return 0 on success, or error
  int repository_state_cleanup(
    ffi.Pointer<git_repository> repo,
  ) {
    return _repository_state_cleanup(
      repo,
    );
  }

  late final _repository_state_cleanupPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<git_repository>)>>(
      'git_repository_state_cleanup');
  late final _repository_state_cleanup = _repository_state_cleanupPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// If a merge is in progress, invoke 'callback' for each commit ID in the
  /// MERGE_HEAD file.
  ///
  /// Return a non-zero value from the callback to stop the loop.
  ///
  /// @param repo A repository object
  /// @param callback Callback function
  /// @param payload Pointer to callback data (optional)
  /// @return 0 on success, non-zero callback return value, GIT_ENOTFOUND if
  /// there is no MERGE_HEAD file, or other error code.
  int repository_mergehead_foreach(
    ffi.Pointer<git_repository> repo,
    git_repository_mergehead_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _repository_mergehead_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _repository_mergehead_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<git_repository>,
              git_repository_mergehead_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_repository_mergehead_foreach');
  late final _repository_mergehead_foreach =
      _repository_mergehead_foreachPtr.asFunction<
          int Function(ffi.Pointer<git_repository>,
              git_repository_mergehead_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// Make the repository HEAD point to the specified reference.
  ///
  /// If the provided reference points to a Tree or a Blob, the HEAD is
  /// unaltered and -1 is returned.
  ///
  /// If the provided reference points to a branch, the HEAD will point
  /// to that branch, staying attached, or become attached if it isn't yet.
  /// If the branch doesn't exist yet, no error will be return. The HEAD
  /// will then be attached to an unborn branch.
  ///
  /// Otherwise, the HEAD will be detached and will directly point to
  /// the Commit.
  ///
  /// @param repo Repository pointer
  /// @param refname Canonical name of the reference the HEAD should point at
  /// @return 0 on success, or an error code
  int repository_set_head(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> refname,
  ) {
    return _repository_set_head(
      repo,
      refname,
    );
  }

  late final _repository_set_headPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Int8>)>>('git_repository_set_head');
  late final _repository_set_head = _repository_set_headPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Int8>)>();

  /// Determines the status of a git repository - ie, whether an operation
  /// (merge, cherry-pick, etc) is in progress.
  ///
  /// @param repo Repository pointer
  /// @return The state of the repository
  int repository_state(
    ffi.Pointer<git_repository> repo,
  ) {
    return _repository_state(
      repo,
    );
  }

  late final _repository_statePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<git_repository>)>>(
      'git_repository_state');
  late final _repository_state = _repository_statePtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Creates a `git_annotated_commit` from the given reference.
  /// The resulting git_annotated_commit must be freed with
  /// `git_annotated_commit_free`.
  ///
  /// @param out pointer to store the git_annotated_commit result in
  /// @param repo repository that contains the given reference
  /// @param ref reference to use to lookup the git_annotated_commit
  /// @return 0 on success or error code
  int annotated_commit_from_ref(
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_reference> ref,
  ) {
    return _annotated_commit_from_ref(
      out,
      repo,
      ref,
    );
  }

  late final _annotated_commit_from_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_reference>)>>('git_annotated_commit_from_ref');
  late final _annotated_commit_from_ref =
      _annotated_commit_from_refPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>, ffi.Pointer<git_reference>)>();

  /// Gets the commit ID that the given `git_annotated_commit` refers to.
  ///
  /// @param commit the given annotated commit
  /// @return commit id
  ffi.Pointer<git_oid> annotated_commit_id(
    ffi.Pointer<git_annotated_commit> commit,
  ) {
    return _annotated_commit_id(
      commit,
    );
  }

  late final _annotated_commit_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_annotated_commit>)>>('git_annotated_commit_id');
  late final _annotated_commit_id = _annotated_commit_idPtr.asFunction<
      ffi.Pointer<git_oid> Function(ffi.Pointer<git_annotated_commit>)>();

  /// Frees a `git_annotated_commit`.
  ///
  /// @param commit annotated commit to free
  void annotated_commit_free(
    ffi.Pointer<git_annotated_commit> commit,
  ) {
    return _annotated_commit_free(
      commit,
    );
  }

  late final _annotated_commit_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<git_annotated_commit>)>>('git_annotated_commit_free');
  late final _annotated_commit_free = _annotated_commit_freePtr
      .asFunction<void Function(ffi.Pointer<git_annotated_commit>)>();

  /// Close an open object
  ///
  /// This method instructs the library to close an existing
  /// object; note that git_objects are owned and cached by the repository
  /// so the object may or may not be freed after this library call,
  /// depending on how aggressive is the caching mechanism used
  /// by the repository.
  ///
  /// IMPORTANT:
  /// It *is* necessary to call this method when you stop using
  /// an object. Failure to do so will cause a memory leak.
  ///
  /// @param object the object to close
  void object_free(
    ffi.Pointer<git_object> object,
  ) {
    return _object_free(
      object,
    );
  }

  late final _object_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_object>)>>(
          'git_object_free');
  late final _object_free =
      _object_freePtr.asFunction<void Function(ffi.Pointer<git_object>)>();

  /// Lookup a tree object from the repository.
  ///
  /// @param out Pointer to the looked up tree
  /// @param repo The repo to use when locating the tree.
  /// @param id Identity of the tree to locate.
  /// @return 0 or an error code
  int tree_lookup(
    ffi.Pointer<ffi.Pointer<git_tree>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _tree_lookup(
      out,
      repo,
      id,
    );
  }

  late final _tree_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<git_tree>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>)>>('git_tree_lookup');
  late final _tree_lookup = _tree_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_tree>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>)>();

  /// Close an open tree
  ///
  /// You can no longer use the git_tree pointer after this call.
  ///
  /// IMPORTANT: You MUST call this method when you stop using a tree to
  /// release memory. Failure to do so will cause a memory leak.
  ///
  /// @param tree The tree to close
  void tree_free(
    ffi.Pointer<git_tree> tree,
  ) {
    return _tree_free(
      tree,
    );
  }

  late final _tree_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_tree>)>>(
          'git_tree_free');
  late final _tree_free =
      _tree_freePtr.asFunction<void Function(ffi.Pointer<git_tree>)>();

  /// Free the strings contained in a string array.  This method should
  /// be called on `git_strarray` objects that were provided by the
  /// library.  Not doing so, will result in a memory leak.
  ///
  /// This does not free the `git_strarray` itself, since the library will
  /// never allocate that object directly itself.
  ///
  /// @param array The git_strarray that contains strings to free
  void strarray_dispose(
    ffi.Pointer<git_strarray> array,
  ) {
    return _strarray_dispose(
      array,
    );
  }

  late final _strarray_disposePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_strarray>)>>(
          'git_strarray_dispose');
  late final _strarray_dispose = _strarray_disposePtr
      .asFunction<void Function(ffi.Pointer<git_strarray>)>();

  /// Lookup a reference by name and resolve immediately to OID.
  ///
  /// This function provides a quick way to resolve a reference name straight
  /// through to the object id that it refers to.  This avoids having to
  /// allocate or free any `git_reference` objects for simple situations.
  ///
  /// The name will be checked for validity.
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param out Pointer to oid to be filled in
  /// @param repo The repository in which to look up the reference
  /// @param name The long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)
  /// @return 0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.
  int reference_name_to_id(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _reference_name_to_id(
      out,
      repo,
      name,
    );
  }

  late final _reference_name_to_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Int8>)>>('git_reference_name_to_id');
  late final _reference_name_to_id = _reference_name_to_idPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Int8>)>();

  /// Lookup a reference by DWIMing its short name
  ///
  /// Apply the git precendence rules to the given shorthand to determine
  /// which reference the user is referring to.
  ///
  /// @param out pointer in which to store the reference
  /// @param repo the repository in which to look
  /// @param shorthand the short name for the reference
  /// @return 0 or an error code
  int reference_dwim(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> shorthand,
  ) {
    return _reference_dwim(
      out,
      repo,
      shorthand,
    );
  }

  late final _reference_dwimPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Int8>)>>('git_reference_dwim');
  late final _reference_dwim = _reference_dwimPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Int8>)>();

  /// Get the OID pointed to by a direct reference.
  ///
  /// Only available if the reference is direct (i.e. an object id reference,
  /// not a symbolic one).
  ///
  /// To find the OID of a symbolic ref, call `git_reference_resolve()` and
  /// then this function (or maybe use `git_reference_name_to_id()` to
  /// directly resolve a reference name all the way through to an OID).
  ///
  /// @param ref The reference
  /// @return a pointer to the oid if available, NULL otherwise
  ffi.Pointer<git_oid> reference_target(
    ffi.Pointer<git_reference> ref,
  ) {
    return _reference_target(
      ref,
    );
  }

  late final _reference_targetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_reference>)>>('git_reference_target');
  late final _reference_target = _reference_targetPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_reference>)>();

  /// Get the full name of a reference.
  ///
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param ref The reference
  /// @return the full name for the ref
  ffi.Pointer<ffi.Int8> reference_name(
    ffi.Pointer<git_reference> ref,
  ) {
    return _reference_name(
      ref,
    );
  }

  late final _reference_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Int8> Function(
              ffi.Pointer<git_reference>)>>('git_reference_name');
  late final _reference_name = _reference_namePtr
      .asFunction<ffi.Pointer<ffi.Int8> Function(ffi.Pointer<git_reference>)>();

  /// Resolve a symbolic reference to a direct reference.
  ///
  /// This method iteratively peels a symbolic reference until it resolves to
  /// a direct reference to an OID.
  ///
  /// The peeled reference is returned in the `resolved_ref` argument, and
  /// must be freed manually once it's no longer needed.
  ///
  /// If a direct reference is passed as an argument, a copy of that
  /// reference is returned. This copy must be manually freed too.
  ///
  /// @param out Pointer to the peeled reference
  /// @param ref The reference
  /// @return 0 or an error code
  int reference_resolve(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> ref,
  ) {
    return _reference_resolve(
      out,
      ref,
    );
  }

  late final _reference_resolvePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>)>>('git_reference_resolve');
  late final _reference_resolve = _reference_resolvePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_reference>)>();

  /// Conditionally create a new reference with the same name as the given reference but a
  /// different OID target. The reference must be a direct reference, otherwise
  /// this will fail.
  ///
  /// The new reference will be written to disk, overwriting the given reference.
  ///
  /// @param out Pointer to the newly created reference
  /// @param ref The reference
  /// @param id The new target OID for the reference
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EMODIFIED if the value of the reference
  /// has changed since it was read, or an error code
  int reference_set_target(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> ref,
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Int8> log_message,
  ) {
    return _reference_set_target(
      out,
      ref,
      id,
      log_message,
    );
  }

  late final _reference_set_targetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Int8>)>>('git_reference_set_target');
  late final _reference_set_target = _reference_set_targetPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_reference>,
          ffi.Pointer<git_oid>,
          ffi.Pointer<ffi.Int8>)>();

  /// Free the given reference.
  ///
  /// @param ref git_reference
  void reference_free(
    ffi.Pointer<git_reference> ref,
  ) {
    return _reference_free(
      ref,
    );
  }

  late final _reference_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_reference>)>>(
      'git_reference_free');
  late final _reference_free = _reference_freePtr
      .asFunction<void Function(ffi.Pointer<git_reference>)>();

  /// Recursively peel reference until object of the specified type is found.
  ///
  /// The retrieved `peeled` object is owned by the repository
  /// and should be closed with the `git_object_free` method.
  ///
  /// If you pass `GIT_OBJECT_ANY` as the target type, then the object
  /// will be peeled until a non-tag object is met.
  ///
  /// @param out Pointer to the peeled git_object
  /// @param ref The reference to be processed
  /// @param type The type of the requested object (GIT_OBJECT_COMMIT,
  /// GIT_OBJECT_TAG, GIT_OBJECT_TREE, GIT_OBJECT_BLOB or GIT_OBJECT_ANY).
  /// @return 0 on success, GIT_EAMBIGUOUS, GIT_ENOTFOUND or an error code
  int reference_peel(
    ffi.Pointer<ffi.Pointer<git_object>> out,
    ffi.Pointer<git_reference> ref,
    int type,
  ) {
    return _reference_peel(
      out,
      ref,
      type,
    );
  }

  late final _reference_peelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_reference>, ffi.Int32)>>('git_reference_peel');
  late final _reference_peel = _reference_peelPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_object>>,
          ffi.Pointer<git_reference>, int)>();

  /// Get the branch name
  ///
  /// Given a reference object, this will check that it really is a branch (ie.
  /// it lives under "refs/heads/" or "refs/remotes/"), and return the branch part
  /// of it.
  ///
  /// @param out Pointer to the abbreviated reference name.
  /// Owned by ref, do not free.
  ///
  /// @param ref A reference object, ideally pointing to a branch
  ///
  /// @return 0 on success; GIT_EINVALID if the reference isn't either a local or
  /// remote branch, otherwise an error code.
  int branch_name(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> out,
    ffi.Pointer<git_reference> ref,
  ) {
    return _branch_name(
      out,
      ref,
    );
  }

  late final _branch_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Pointer<ffi.Int8>>,
              ffi.Pointer<git_reference>)>>('git_branch_name');
  late final _branch_name = _branch_namePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Int8>>, ffi.Pointer<git_reference>)>();

  /// Get the upstream of a branch
  ///
  /// Given a reference, this will return a new reference object corresponding
  /// to its remote tracking branch. The reference must be a local branch.
  ///
  /// @see git_branch_upstream_name for details on the resolution.
  ///
  /// @param out Pointer where to store the retrieved reference.
  /// @param branch Current underlying reference of the branch.
  ///
  /// @return 0 on success; GIT_ENOTFOUND when no remote tracking
  /// reference exists, otherwise an error code.
  int branch_upstream(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> branch,
  ) {
    return _branch_upstream(
      out,
      branch,
    );
  }

  late final _branch_upstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>)>>('git_branch_upstream');
  late final _branch_upstream = _branch_upstreamPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_reference>)>();

  /// Initialize git_checkout_options structure
  ///
  /// Initializes a `git_checkout_options` with default values. Equivalent to creating
  /// an instance with GIT_CHECKOUT_OPTIONS_INIT.
  ///
  /// @param opts The `git_checkout_options` struct to initialize.
  /// @param version The struct version; pass `GIT_CHECKOUT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int checkout_options_init(
    ffi.Pointer<git_checkout_options> opts,
    int version,
  ) {
    return _checkout_options_init(
      opts,
      version,
    );
  }

  late final _checkout_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<git_checkout_options>,
              ffi.Uint32)>>('git_checkout_options_init');
  late final _checkout_options_init = _checkout_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_checkout_options>, int)>();

  /// Updates files in the index and the working tree to match the content of
  /// the commit pointed at by HEAD.
  ///
  /// Note that this is _not_ the correct mechanism used to switch branches;
  /// do not change your `HEAD` and then call this method, that would leave
  /// you with checkout conflicts since your working directory would then
  /// appear to be dirty.  Instead, checkout the target of the branch and
  /// then update `HEAD` using `git_repository_set_head` to point to the
  /// branch you checked out.
  ///
  /// @param repo repository to check out (must be non-bare)
  /// @param opts specifies checkout options (may be NULL)
  /// @return 0 on success, GIT_EUNBORNBRANCH if HEAD points to a non
  /// existing branch, non-zero value returned by `notify_cb`, or
  /// other error code < 0 (use git_error_last for error details)
  int checkout_head(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_checkout_options> opts,
  ) {
    return _checkout_head(
      repo,
      opts,
    );
  }

  late final _checkout_headPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<git_repository>,
              ffi.Pointer<git_checkout_options>)>>('git_checkout_head');
  late final _checkout_head = _checkout_headPtr.asFunction<
      int Function(
          ffi.Pointer<git_repository>, ffi.Pointer<git_checkout_options>)>();

  /// Updates files in the index and working tree to match the content of the
  /// tree pointed at by the treeish.
  ///
  /// @param repo repository to check out (must be non-bare)
  /// @param treeish a commit, tag or tree which content will be used to update
  /// the working directory (or NULL to use HEAD)
  /// @param opts specifies checkout options (may be NULL)
  /// @return 0 on success, non-zero return value from `notify_cb`, or error
  /// code < 0 (use git_error_last for error details)
  int checkout_tree(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_object> treeish,
    ffi.Pointer<git_checkout_options> opts,
  ) {
    return _checkout_tree(
      repo,
      treeish,
      opts,
    );
  }

  late final _checkout_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_object>,
              ffi.Pointer<git_checkout_options>)>>('git_checkout_tree');
  late final _checkout_tree = _checkout_treePtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_object>,
          ffi.Pointer<git_checkout_options>)>();

  /// Free an existing index object.
  ///
  /// @param index an existing index object
  void index_free(
    ffi.Pointer<git_index> index,
  ) {
    return _index_free(
      index,
    );
  }

  late final _index_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_index>)>>(
          'git_index_free');
  late final _index_free =
      _index_freePtr.asFunction<void Function(ffi.Pointer<git_index>)>();

  /// Write an existing index object from memory back to disk
  /// using an atomic file lock.
  ///
  /// @param index an existing index object
  /// @return 0 or an error code
  int index_write(
    ffi.Pointer<git_index> index,
  ) {
    return _index_write(
      index,
    );
  }

  late final _index_writePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<git_index>)>>(
          'git_index_write');
  late final _index_write =
      _index_writePtr.asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Write the index as a tree
  ///
  /// This method will scan the index and write a representation
  /// of its current state back to disk; it recursively creates
  /// tree objects for each of the subtrees stored in the index,
  /// but only returns the OID of the root tree. This is the OID
  /// that can be used e.g. to create a commit.
  ///
  /// The index instance cannot be bare, and needs to be associated
  /// to an existing repository.
  ///
  /// The index must not contain any file in conflict.
  ///
  /// @param out Pointer where to store the OID of the written tree
  /// @param index Index to write
  /// @return 0 on success, GIT_EUNMERGED when the index is not clean
  /// or an error code
  int index_write_tree(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_index> index,
  ) {
    return _index_write_tree(
      out,
      index,
    );
  }

  late final _index_write_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<git_oid>,
              ffi.Pointer<git_index>)>>('git_index_write_tree');
  late final _index_write_tree = _index_write_treePtr
      .asFunction<int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_index>)>();

  /// Add or update an index entry from a file on disk
  ///
  /// The file `path` must be relative to the repository's
  /// working folder and must be readable.
  ///
  /// This method will fail in bare index instances.
  ///
  /// This forces the file to be added to the index, not looking
  /// at gitignore rules.  Those rules can be evaluated through
  /// the git_status APIs (in status.h) before calling this.
  ///
  /// If this file currently is the result of a merge conflict, this
  /// file will no longer be marked as conflicting.  The data about
  /// the conflict will be moved to the "resolve undo" (REUC) section.
  ///
  /// @param index an existing index object
  /// @param path filename to add
  /// @return 0 or an error code
  int index_add_bypath(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _index_add_bypath(
      index,
      path,
    );
  }

  late final _index_add_bypathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Int8>)>>('git_index_add_bypath');
  late final _index_add_bypath = _index_add_bypathPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Int8>)>();

  /// Remove an index entry corresponding to a file on disk
  ///
  /// The file `path` must be relative to the repository's
  /// working folder.  It may exist.
  ///
  /// If this file currently is the result of a merge conflict, this
  /// file will no longer be marked as conflicting.  The data about
  /// the conflict will be moved to the "resolve undo" (REUC) section.
  ///
  /// @param index an existing index object
  /// @param path filename to remove
  /// @return 0 or an error code
  int index_remove_bypath(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _index_remove_bypath(
      index,
      path,
    );
  }

  late final _index_remove_bypathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Int8>)>>('git_index_remove_bypath');
  late final _index_remove_bypath = _index_remove_bypathPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Int8>)>();

  /// Initialize git_merge_options structure
  ///
  /// Initializes a `git_merge_options` with default values. Equivalent to
  /// creating an instance with `GIT_MERGE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_merge_options` struct to initialize.
  /// @param version The struct version; pass `GIT_MERGE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int merge_options_init(
    ffi.Pointer<git_merge_options> opts,
    int version,
  ) {
    return _merge_options_init(
      opts,
      version,
    );
  }

  late final _merge_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<git_merge_options>,
              ffi.Uint32)>>('git_merge_options_init');
  late final _merge_options_init = _merge_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_merge_options>, int)>();

  /// Analyzes the given branch(es) and determines the opportunities for
  /// merging them into the HEAD of the repository.
  ///
  /// @param analysis_out analysis enumeration that the result is written into
  /// @param repo the repository to merge
  /// @param their_heads the heads to merge into
  /// @param their_heads_len the number of heads to merge
  /// @return 0 on success or error code
  int merge_analysis(
    ffi.Pointer<ffi.Int32> analysis_out,
    ffi.Pointer<ffi.Int32> preference_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
    int their_heads_len,
  ) {
    return _merge_analysis(
      analysis_out,
      preference_out,
      repo,
      their_heads,
      their_heads_len,
    );
  }

  late final _merge_analysisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.IntPtr)>>('git_merge_analysis');
  late final _merge_analysis = _merge_analysisPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
          int)>();

  /// Merges the given commit(s) into HEAD, writing the results into the working
  /// directory.  Any changes are staged for commit and any conflicts are written
  /// to the index.  Callers should inspect the repository's index after this
  /// completes, resolve any conflicts and prepare a commit.
  ///
  /// For compatibility with git, the repository is put into a merging
  /// state. Once the commit is done (or if the uses wishes to abort),
  /// you should clear this state by calling
  /// `git_repository_state_cleanup()`.
  ///
  /// @param repo the repository to merge
  /// @param their_heads the heads to merge into
  /// @param their_heads_len the number of heads to merge
  /// @param merge_opts merge options
  /// @param checkout_opts checkout options
  /// @return 0 on success or error code
  int merge(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
    int their_heads_len,
    ffi.Pointer<git_merge_options> merge_opts,
    ffi.Pointer<git_checkout_options> checkout_opts,
  ) {
    return _merge(
      repo,
      their_heads,
      their_heads_len,
      merge_opts,
      checkout_opts,
    );
  }

  late final _mergePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.IntPtr,
              ffi.Pointer<git_merge_options>,
              ffi.Pointer<git_checkout_options>)>>('git_merge');
  late final _merge = _mergePtr.asFunction<
      int Function(
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
          int,
          ffi.Pointer<git_merge_options>,
          ffi.Pointer<git_checkout_options>)>();

  /// Create a new plain-text username and password credential object.
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param out The newly created credential object.
  /// @param username The username of the credential.
  /// @param password The password of the credential.
  /// @return 0 for success or an error code for failure
  int credential_userpass_plaintext_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> username,
    ffi.Pointer<ffi.Int8> password,
  ) {
    return _credential_userpass_plaintext_new(
      out,
      username,
      password,
    );
  }

  late final _credential_userpass_plaintext_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('git_credential_userpass_plaintext_new');
  late final _credential_userpass_plaintext_new =
      _credential_userpass_plaintext_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  /// Add a remote with the default fetch refspec to the repository's configuration.
  ///
  /// @param out the resulting remote
  /// @param repo the repository in which to create the remote
  /// @param name the remote's name
  /// @param url the remote's url
  /// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int remote_create(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> url,
  ) {
    return _remote_create(
      out,
      repo,
      name,
      url,
    );
  }

  late final _remote_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('git_remote_create');
  late final _remote_create = _remote_createPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_remote>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Int8>)>();

  /// Get the information for a particular remote
  ///
  /// The name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// @param out pointer to the new remote object
  /// @param repo the associated repository
  /// @param name the remote's name
  /// @return 0, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code
  int remote_lookup(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _remote_lookup(
      out,
      repo,
      name,
    );
  }

  late final _remote_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Int8>)>>('git_remote_lookup');
  late final _remote_lookup = _remote_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_remote>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Int8>)>();

  /// Free the memory associated with a remote
  ///
  /// This also disconnects from the remote, if the connection
  /// has not been closed yet (using git_remote_disconnect).
  ///
  /// @param remote the remote to free
  void remote_free(
    ffi.Pointer<git_remote> remote,
  ) {
    return _remote_free(
      remote,
    );
  }

  late final _remote_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_remote>)>>(
          'git_remote_free');
  late final _remote_free =
      _remote_freePtr.asFunction<void Function(ffi.Pointer<git_remote>)>();

  /// Get a list of the configured remotes for a repo
  ///
  /// The string array must be freed by the user.
  ///
  /// @param out a string array which receives the names of the remotes
  /// @param repo the repository to query
  /// @return 0 or an error code
  int remote_list(
    ffi.Pointer<git_strarray> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _remote_list(
      out,
      repo,
    );
  }

  late final _remote_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<git_strarray>,
              ffi.Pointer<git_repository>)>>('git_remote_list');
  late final _remote_list = _remote_listPtr.asFunction<
      int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_repository>)>();

  /// Initialize git_fetch_options structure
  ///
  /// Initializes a `git_fetch_options` with default values. Equivalent to
  /// creating an instance with `GIT_FETCH_OPTIONS_INIT`.
  ///
  /// @param opts The `git_fetch_options` struct to initialize.
  /// @param version The struct version; pass `GIT_FETCH_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int fetch_options_init(
    ffi.Pointer<git_fetch_options> opts,
    int version,
  ) {
    return _fetch_options_init(
      opts,
      version,
    );
  }

  late final _fetch_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<git_fetch_options>,
              ffi.Uint32)>>('git_fetch_options_init');
  late final _fetch_options_init = _fetch_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_fetch_options>, int)>();

  /// Initialize git_push_options structure
  ///
  /// Initializes a `git_push_options` with default values. Equivalent to
  /// creating an instance with `GIT_PUSH_OPTIONS_INIT`.
  ///
  /// @param opts The `git_push_options` struct to initialize.
  /// @param version The struct version; pass `GIT_PUSH_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int push_options_init(
    ffi.Pointer<git_push_options> opts,
    int version,
  ) {
    return _push_options_init(
      opts,
      version,
    );
  }

  late final _push_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<git_push_options>,
              ffi.Uint32)>>('git_push_options_init');
  late final _push_options_init = _push_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_push_options>, int)>();

  /// Download new data and update tips
  ///
  /// Convenience function to connect to a remote, download the data,
  /// disconnect and update the remote-tracking branches.
  ///
  /// @param remote the remote to fetch from
  /// @param refspecs the refspecs to use for this fetch. Pass NULL or an
  /// empty array to use the base refspecs.
  /// @param opts options to use for this fetch
  /// @param reflog_message The message to insert into the reflogs. If NULL, the
  /// default is "fetch"
  /// @return 0 or an error code
  int remote_fetch(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_fetch_options> opts,
    ffi.Pointer<ffi.Int8> reflog_message,
  ) {
    return _remote_fetch(
      remote,
      refspecs,
      opts,
      reflog_message,
    );
  }

  late final _remote_fetchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<git_remote>,
              ffi.Pointer<git_strarray>,
              ffi.Pointer<git_fetch_options>,
              ffi.Pointer<ffi.Int8>)>>('git_remote_fetch');
  late final _remote_fetch = _remote_fetchPtr.asFunction<
      int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
          ffi.Pointer<git_fetch_options>, ffi.Pointer<ffi.Int8>)>();

  /// Perform a push
  ///
  /// Peform all the steps from a push.
  ///
  /// @param remote the remote to push to
  /// @param refspecs the refspecs to use for pushing. If NULL or an empty
  /// array, the configured refspecs will be used
  /// @param opts options to use for this push
  int remote_push(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_push_options> opts,
  ) {
    return _remote_push(
      remote,
      refspecs,
      opts,
    );
  }

  late final _remote_pushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
              ffi.Pointer<git_push_options>)>>('git_remote_push');
  late final _remote_push = _remote_pushPtr.asFunction<
      int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
          ffi.Pointer<git_push_options>)>();

  /// Delete an existing persisted remote.
  ///
  /// All remote-tracking branches and configuration settings
  /// for the remote will be removed.
  ///
  /// @param repo the repository in which to act
  /// @param name the name of the remote to delete
  /// @return 0 on success, or an error code.
  int remote_delete(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _remote_delete(
      repo,
      name,
    );
  }

  late final _remote_deletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Int8>)>>('git_remote_delete');
  late final _remote_delete = _remote_deletePtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Int8>)>();

  /// Initialize git_clone_options structure
  ///
  /// Initializes a `git_clone_options` with default values. Equivalent to creating
  /// an instance with GIT_CLONE_OPTIONS_INIT.
  ///
  /// @param opts The `git_clone_options` struct to initialize.
  /// @param version The struct version; pass `GIT_CLONE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int clone_options_init(
    ffi.Pointer<git_clone_options> opts,
    int version,
  ) {
    return _clone_options_init(
      opts,
      version,
    );
  }

  late final _clone_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<git_clone_options>,
              ffi.Uint32)>>('git_clone_options_init');
  late final _clone_options_init = _clone_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_clone_options>, int)>();

  /// Clone a remote repository.
  ///
  /// By default this creates its repository and initial remote to match
  /// git's defaults. You can use the options in the callback to
  /// customize how these are created.
  ///
  /// @param out pointer that will receive the resulting repository object
  /// @param url the remote repository to clone
  /// @param local_path local directory to clone to
  /// @param options configuration options for the clone.  If NULL, the
  /// function works as though GIT_OPTIONS_INIT were passed.
  /// @return 0 on success, any non-zero return value from a callback
  /// function, or a negative value to indicate an error (use
  /// `git_error_last` for a detailed error message)
  int clone(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> url,
    ffi.Pointer<ffi.Int8> local_path,
    ffi.Pointer<git_clone_options> options,
  ) {
    return _clone(
      out,
      url,
      local_path,
      options,
    );
  }

  late final _clonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<git_clone_options>)>>('git_clone');
  late final _clone = _clonePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Int8>,
          ffi.Pointer<git_clone_options>)>();

  /// Lookup a commit object from a repository.
  ///
  /// The returned object should be released with `git_commit_free` when no
  /// longer needed.
  ///
  /// @param commit pointer to the looked up commit
  /// @param repo the repo to use when locating the commit.
  /// @param id identity of the commit to locate. If the object is
  /// an annotated tag it will be peeled back to the commit.
  /// @return 0 or an error code
  int commit_lookup(
    ffi.Pointer<ffi.Pointer<git_commit>> commit,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _commit_lookup(
      commit,
      repo,
      id,
    );
  }

  late final _commit_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<git_commit>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>)>>('git_commit_lookup');
  late final _commit_lookup = _commit_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_commit>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>)>();

  /// Close an open commit
  ///
  /// This is a wrapper around git_object_free()
  ///
  /// IMPORTANT:
  /// It *is* necessary to call this method when you stop
  /// using a commit. Failure to do so will cause a memory leak.
  ///
  /// @param commit the commit to close
  void commit_free(
    ffi.Pointer<git_commit> commit,
  ) {
    return _commit_free(
      commit,
    );
  }

  late final _commit_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_commit>)>>(
          'git_commit_free');
  late final _commit_free =
      _commit_freePtr.asFunction<void Function(ffi.Pointer<git_commit>)>();

  /// Create new commit in the repository from a list of `git_object` pointers
  ///
  /// The message will **not** be cleaned up automatically. You can do that
  /// with the `git_message_prettify()` function.
  ///
  /// @param id Pointer in which to store the OID of the newly created commit
  ///
  /// @param repo Repository where to store the commit
  ///
  /// @param update_ref If not NULL, name of the reference that
  /// will be updated to point to this commit. If the reference
  /// is not direct, it will be resolved to a direct reference.
  /// Use "HEAD" to update the HEAD of the current branch and
  /// make it point to this commit. If the reference doesn't
  /// exist yet, it will be created. If it does exist, the first
  /// parent must be the tip of this branch.
  ///
  /// @param author Signature with author and author time of commit
  ///
  /// @param committer Signature with committer and * commit time of commit
  ///
  /// @param message_encoding The encoding for the message in the
  /// commit, represented with a standard encoding name.
  /// E.g. "UTF-8". If NULL, no encoding header is written and
  /// UTF-8 is assumed.
  ///
  /// @param message Full message for this commit
  ///
  /// @param tree An instance of a `git_tree` object that will
  /// be used as the tree for the commit. This tree object must
  /// also be owned by the given `repo`.
  ///
  /// @param parent_count Number of parents for this commit
  ///
  /// @param parents Array of `parent_count` pointers to `git_commit`
  /// objects that will be used as the parents for this commit. This
  /// array may be NULL if `parent_count` is 0 (root commit). All the
  /// given commits must be owned by the `repo`.
  ///
  /// @return 0 or an error code
  /// The created commit will be written to the Object Database and
  /// the given reference will be updated to point to it
  int commit_create(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> update_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Int8> message_encoding,
    ffi.Pointer<ffi.Int8> message,
    ffi.Pointer<git_tree> tree,
    int parent_count,
    ffi.Pointer<ffi.Pointer<git_commit>> parents,
  ) {
    return _commit_create(
      id,
      repo,
      update_ref,
      author,
      committer,
      message_encoding,
      message,
      tree,
      parent_count,
      parents,
    );
  }

  late final _commit_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<git_tree>,
              ffi.IntPtr,
              ffi.Pointer<ffi.Pointer<git_commit>>)>>('git_commit_create');
  late final _commit_create = _commit_createPtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Int8>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<ffi.Int8>,
          ffi.Pointer<ffi.Int8>,
          ffi.Pointer<git_tree>,
          int,
          ffi.Pointer<ffi.Pointer<git_commit>>)>();

  /// Return the last `git_error` object that was generated for the
  /// current thread.
  ///
  /// The default behaviour of this function is to return NULL if no previous error has occurred.
  /// However, libgit2's error strings are not cleared aggressively, so a prior
  /// (unrelated) error may be returned. This can be avoided by only calling
  /// this function if the prior call to a libgit2 API returned an error.
  ///
  /// @return A git_error object.
  ffi.Pointer<git_error> error_last() {
    return _error_last();
  }

  late final _error_lastPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<git_error> Function()>>(
          'git_error_last');
  late final _error_last =
      _error_lastPtr.asFunction<ffi.Pointer<git_error> Function()>();

  /// Set the error message string for this thread.
  ///
  /// This function is public so that custom ODB backends and the like can
  /// relay an error message through libgit2.  Most regular users of libgit2
  /// will never need to call this function -- actually, calling it in most
  /// circumstances (for example, calling from within a callback function)
  /// will just end up having the value overwritten by libgit2 internals.
  ///
  /// This error message is stored in thread-local storage and only applies
  /// to the particular thread that this libgit2 call is made from.
  ///
  /// @param error_class One of the `git_error_t` enum above describing the
  /// general subsystem that is responsible for the error.
  /// @param string The formatted error message to keep
  /// @return 0 on success or -1 on failure
  int error_set_str(
    int error_class,
    ffi.Pointer<ffi.Int8> string,
  ) {
    return _error_set_str(
      error_class,
      string,
    );
  }

  late final _error_set_strPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Int32, ffi.Pointer<ffi.Int8>)>>('git_error_set_str');
  late final _error_set_str =
      _error_set_strPtr.asFunction<int Function(int, ffi.Pointer<ffi.Int8>)>();

  /// Initialize git_status_options structure
  ///
  /// Initializes a `git_status_options` with default values. Equivalent to
  /// creating an instance with `GIT_STATUS_OPTIONS_INIT`.
  ///
  /// @param opts The `git_status_options` struct to initialize.
  /// @param version The struct version; pass `GIT_STATUS_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int status_options_init(
    ffi.Pointer<git_status_options> opts,
    int version,
  ) {
    return _status_options_init(
      opts,
      version,
    );
  }

  late final _status_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<git_status_options>,
              ffi.Uint32)>>('git_status_options_init');
  late final _status_options_init = _status_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_status_options>, int)>();

  /// Gather file status information and populate the `git_status_list`.
  ///
  /// Note that if a `pathspec` is given in the `git_status_options` to filter
  /// the status, then the results from rename detection (if you enable it) may
  /// not be accurate.  To do rename detection properly, this must be called
  /// with no `pathspec` so that all files can be considered.
  ///
  /// @param out Pointer to store the status results in
  /// @param repo Repository object
  /// @param opts Status options structure
  /// @return 0 on success or error code
  int status_list_new(
    ffi.Pointer<ffi.Pointer<git_status_list>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_status_options> opts,
  ) {
    return _status_list_new(
      out,
      repo,
      opts,
    );
  }

  late final _status_list_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<git_status_list>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_status_options>)>>('git_status_list_new');
  late final _status_list_new = _status_list_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_status_list>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_status_options>)>();

  /// Gets the count of status entries in this list.
  ///
  /// If there are no changes in status (at least according the options given
  /// when the status list was created), this can return 0.
  ///
  /// @param statuslist Existing status list object
  /// @return the number of status entries
  int status_list_entrycount(
    ffi.Pointer<git_status_list> statuslist,
  ) {
    return _status_list_entrycount(
      statuslist,
    );
  }

  late final _status_list_entrycountPtr = _lookup<
      ffi.NativeFunction<
          ffi.IntPtr Function(
              ffi.Pointer<git_status_list>)>>('git_status_list_entrycount');
  late final _status_list_entrycount = _status_list_entrycountPtr
      .asFunction<int Function(ffi.Pointer<git_status_list>)>();

  /// Get a pointer to one of the entries in the status list.
  ///
  /// The entry is not modifiable and should not be freed.
  ///
  /// @param statuslist Existing status list object
  /// @param idx Position of the entry
  /// @return Pointer to the entry; NULL if out of bounds
  ffi.Pointer<git_status_entry> status_byindex(
    ffi.Pointer<git_status_list> statuslist,
    int idx,
  ) {
    return _status_byindex(
      statuslist,
      idx,
    );
  }

  late final _status_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_status_entry> Function(
              ffi.Pointer<git_status_list>, ffi.IntPtr)>>('git_status_byindex');
  late final _status_byindex = _status_byindexPtr.asFunction<
      ffi.Pointer<git_status_entry> Function(
          ffi.Pointer<git_status_list>, int)>();

  /// Free an existing status list
  ///
  /// @param statuslist Existing status list object
  void status_list_free(
    ffi.Pointer<git_status_list> statuslist,
  ) {
    return _status_list_free(
      statuslist,
    );
  }

  late final _status_list_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_status_list>)>>(
      'git_status_list_free');
  late final _status_list_free = _status_list_freePtr
      .asFunction<void Function(ffi.Pointer<git_status_list>)>();

  /// Init the global state
  ///
  /// This function must be called before any other libgit2 function in
  /// order to set up global state and threading.
  ///
  /// This function may be called multiple times - it will return the number
  /// of times the initialization has been called (including this one) that have
  /// not subsequently been shutdown.
  ///
  /// @return the number of initializations of the library, or an error code.
  int libgit2_init() {
    return _libgit2_init();
  }

  late final _libgit2_initPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('git_libgit2_init');
  late final _libgit2_init = _libgit2_initPtr.asFunction<int Function()>();

  /// Shutdown the global state
  ///
  /// Clean up the global state and threading context after calling it as
  /// many times as `git_libgit2_init()` was called - it will return the
  /// number of remainining initializations that have not been shutdown
  /// (after this one).
  ///
  /// @return the number of remaining initializations of the library, or an
  /// error code.
  int libgit2_shutdown() {
    return _libgit2_shutdown();
  }

  late final _libgit2_shutdownPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>('git_libgit2_shutdown');
  late final _libgit2_shutdown =
      _libgit2_shutdownPtr.asFunction<int Function()>();

  /// Count the number of unique commits between two commit objects
  ///
  /// There is no need for branches containing the commits to have any
  /// upstream relationship, but it helps to think of one as a branch and
  /// the other as its upstream, the `ahead` and `behind` values will be
  /// what git would report for the branches.
  ///
  /// @param ahead number of unique from commits in `upstream`
  /// @param behind number of unique from commits in `local`
  /// @param repo the repository where the commits exist
  /// @param local the commit for local
  /// @param upstream the commit for upstream
  int graph_ahead_behind(
    ffi.Pointer<ffi.IntPtr> ahead,
    ffi.Pointer<ffi.IntPtr> behind,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> local,
    ffi.Pointer<git_oid> upstream,
  ) {
    return _graph_ahead_behind(
      ahead,
      behind,
      repo,
      local,
      upstream,
    );
  }

  late final _graph_ahead_behindPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<ffi.IntPtr>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_oid>)>>('git_graph_ahead_behind');
  late final _graph_ahead_behind = _graph_ahead_behindPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.IntPtr>,
          ffi.Pointer<ffi.IntPtr>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_oid>)>();

  /// Updates some entries in the index from the target commit tree.
  ///
  /// The scope of the updated entries is determined by the paths
  /// being passed in the `pathspec` parameters.
  ///
  /// Passing a NULL `target` will result in removing
  /// entries in the index matching the provided pathspecs.
  ///
  /// @param repo Repository where to perform the reset operation.
  ///
  /// @param target The committish which content will be used to reset the content
  /// of the index.
  ///
  /// @param pathspecs List of pathspecs to operate on.
  ///
  /// @return 0 on success or an error code < 0
  int reset_default(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_object> target,
    ffi.Pointer<git_strarray> pathspecs,
  ) {
    return _reset_default(
      repo,
      target,
      pathspecs,
    );
  }

  late final _reset_defaultPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_object>,
              ffi.Pointer<git_strarray>)>>('git_reset_default');
  late final _reset_default = _reset_defaultPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_object>,
          ffi.Pointer<git_strarray>)>();

  /// Create a new action signature with a timestamp of 'now'.
  ///
  /// Call `git_signature_free()` to free the data.
  ///
  /// @param out new signature, in case of error NULL
  /// @param name name of the person
  /// @param email email of the person
  /// @return 0 or an error code
  int signature_now(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> email,
  ) {
    return _signature_now(
      out,
      name,
      email,
    );
  }

  late final _signature_nowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int32 Function(
              ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<ffi.Int8>,
              ffi.Pointer<ffi.Int8>)>>('git_signature_now');
  late final _signature_now = _signature_nowPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
          ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>)>();

  /// Free an existing signature.
  ///
  /// Because the signature is not an opaque structure, it is legal to free it
  /// manually, but be sure to free the "name" and "email" strings in addition
  /// to the structure itself.
  ///
  /// @param sig signature to free
  void signature_free(
    ffi.Pointer<git_signature> sig,
  ) {
    return _signature_free(
      sig,
    );
  }

  late final _signature_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_signature>)>>(
      'git_signature_free');
  late final _signature_free = _signature_freePtr
      .asFunction<void Function(ffi.Pointer<git_signature>)>();
}

class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Int8> __mbstate8;

  @ffi.Int64()
  external int _mbstateL;
}

class sigval extends ffi.Union {
  @ffi.Int32()
  external int sival_int;

  external ffi.Pointer<ffi.Void> sival_ptr;
}

class __sigaction_u extends ffi.Union {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int32)>>
      __sa_handler;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Int32, ffi.Pointer<__siginfo>, ffi.Pointer<ffi.Void>)>>
      __sa_sigaction;
}

class __siginfo extends ffi.Opaque {}

class wait extends ffi.Opaque {}

/// A data buffer for exporting data from libgit2
///
/// Sometimes libgit2 wants to return an allocated data buffer to the
/// caller and have the caller take responsibility for freeing that memory.
/// This can be awkward if the caller does not have easy access to the same
/// allocation functions that libgit2 is using.  In those cases, libgit2
/// will fill in a `git_buf` and the caller can use `git_buf_dispose()` to
/// release it when they are done.
///
/// A `git_buf` may also be used for the caller to pass in a reference to
/// a block of memory they hold.  In this case, libgit2 will not resize or
/// free the memory, but will read from it as needed.
///
/// Some APIs may occasionally do something slightly unusual with a buffer,
/// such as setting `ptr` to a value that was passed in by the user.  In
/// those cases, the behavior will be clearly documented by the API.
class git_buf extends ffi.Struct {
  /// The buffer contents.
  ///
  /// `ptr` points to the start of the allocated memory.  If it is NULL,
  /// then the `git_buf` is considered empty and libgit2 will feel free
  /// to overwrite it with new data.
  external ffi.Pointer<ffi.Int8> ptr;

  /// `asize` holds the known total amount of allocated memory if the `ptr`
  /// was allocated by libgit2.  It may be larger than `size`.  If `ptr`
  /// was not allocated by libgit2 and should not be resized and/or freed,
  /// then `asize` will be set to zero.
  @ffi.IntPtr()
  external int asize;

  /// `size` holds the size (in bytes) of the data that is actually used.
  @ffi.IntPtr()
  external int size;
}

/// Unique identity of any object (commit, tree, blob, tag).
class git_oid extends ffi.Struct {
  @ffi.Array.multi([20])
  external ffi.Array<ffi.Uint8> id;
}

/// Basic type (loose or packed) of any Git object.
abstract class git_object_t {
  /// < Object can be any of the following
  static const int GIT_OBJECT_ANY = -2;

  /// < Object is invalid.
  static const int GIT_OBJECT_INVALID = -1;

  /// < A commit object.
  static const int GIT_OBJECT_COMMIT = 1;

  /// < A tree (directory listing) object.
  static const int GIT_OBJECT_TREE = 2;

  /// < A file revision object.
  static const int GIT_OBJECT_BLOB = 3;

  /// < An annotated tag object.
  static const int GIT_OBJECT_TAG = 4;

  /// < A delta, base is given by an offset.
  static const int GIT_OBJECT_OFS_DELTA = 6;

  /// < A delta, base is given by object id.
  static const int GIT_OBJECT_REF_DELTA = 7;
}

/// An action signature (e.g. for committers, taggers, etc)
class git_signature extends ffi.Struct {
  /// < full name of the author
  external ffi.Pointer<ffi.Int8> name;

  /// < email of the author
  external ffi.Pointer<ffi.Int8> email;

  /// < time when the action happened
  external git_time when;
}

/// Time in a signature
class git_time extends ffi.Struct {
  /// < time in seconds from epoch
  @git_time_t()
  external int time;

  /// < timezone offset, in minutes
  @ffi.Int32()
  external int offset;

  /// < indicator for questionable '-0000' offsets in signature
  @ffi.Int8()
  external int sign;
}

typedef git_time_t = ffi.Int64;

/// The callback settings structure
///
/// Set the callbacks to be called by the remote when informing the user
/// about the progress of the network operations.
class git_remote_callbacks extends ffi.Struct {
  /// < The version
  @ffi.Uint32()
  external int version;

  /// Textual progress from the remote. Text send over the
  /// progress side-band will be passed to this function (this is
  /// the 'counting objects' output).
  external git_transport_message_cb sideband_progress;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Int32, ffi.Pointer<ffi.Void>)>> completion;

  /// This will be called if the remote host requires
  /// authentication in order to connect to it.
  ///
  /// Returning GIT_PASSTHROUGH will make libgit2 behave as
  /// though this field isn't set.
  external git_credential_acquire_cb credentials;

  /// If cert verification fails, this will be called to let the
  /// user make the final decision of whether to allow the
  /// connection to proceed. Returns 0 to allow the connection
  /// or a negative value to indicate an error.
  external git_transport_certificate_check_cb certificate_check;

  /// During the download of new data, this will be regularly
  /// called with the current count of progress done by the
  /// indexer.
  external git_indexer_progress_cb transfer_progress;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int32 Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<git_oid>,
              ffi.Pointer<git_oid>, ffi.Pointer<ffi.Void>)>> update_tips;

  /// Function to call with progress information during pack
  /// building. Be aware that this is called inline with pack
  /// building operations, so performance may be affected.
  external git_packbuilder_progress pack_progress;

  /// Function to call with progress information during the
  /// upload portion of a push. Be aware that this is called
  /// inline with pack building operations, so performance may be
  /// affected.
  external git_push_transfer_progress_cb push_transfer_progress;

  /// See documentation of git_push_update_reference_cb
  external git_push_update_reference_cb push_update_reference;

  /// Called once between the negotiation step and the upload. It
  /// provides information about what updates will be performed.
  external git_push_negotiation push_negotiation;

  /// Create the transport to use for this operation. Leave NULL
  /// to auto-detect.
  external git_transport_cb transport;

  /// Callback when the remote is ready to connect.
  external git_remote_ready_cb remote_ready;

  /// This will be passed to each of the callbacks in this struct
  /// as the last parameter.
  external ffi.Pointer<ffi.Void> payload;

  /// Resolve URL before connecting to remote.
  /// The returned URL will be used to connect to the remote instead.
  ///
  /// This callback is deprecated; users should use
  /// git_remote_ready_cb and configure the instance URL instead.
  external git_url_resolve_cb resolve_url;
}

/// Callback for messages received by the transport.
///
/// Return a negative value to cancel the network operation.
///
/// @param str The message from the transport
/// @param len The length of the message
/// @param payload Payload provided by the caller
typedef git_transport_message_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(
            ffi.Pointer<ffi.Int8>, ffi.Int32, ffi.Pointer<ffi.Void>)>>;

/// Argument to the completion callback which tells it which operation
/// finished.
abstract class git_remote_completion_t {
  static const int GIT_REMOTE_COMPLETION_DOWNLOAD = 0;
  static const int GIT_REMOTE_COMPLETION_INDEXING = 1;
  static const int GIT_REMOTE_COMPLETION_ERROR = 2;
}

/// Credential acquisition callback.
///
/// This callback is usually involved any time another system might need
/// authentication. As such, you are expected to provide a valid
/// git_credential object back, depending on allowed_types (a
/// git_credential_t bitmask).
///
/// Note that most authentication details are your responsibility - this
/// callback will be called until the authentication succeeds, or you report
/// an error. As such, it's easy to get in a loop if you fail to stop providing
/// the same incorrect credentials.
///
/// @param out The newly created credential object.
/// @param url The resource for which we are demanding a credential.
/// @param username_from_url The username that was embedded in a "user\@host"
/// remote url, or NULL if not included.
/// @param allowed_types A bitmask stating which credential types are OK to return.
/// @param payload The payload provided when specifying this callback.
/// @return 0 for success, < 0 to indicate an error, > 0 to indicate
/// no credential was acquired
typedef git_credential_acquire_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(
            ffi.Pointer<ffi.Pointer<git_credential>>,
            ffi.Pointer<ffi.Int8>,
            ffi.Pointer<ffi.Int8>,
            ffi.Uint32,
            ffi.Pointer<ffi.Void>)>>;

/// The base structure for all credential types
class git_credential extends ffi.Struct {
  /// < A type of credential
  @ffi.Int32()
  external int credtype;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_credential>)>> free;
}

/// Supported credential types
///
/// This represents the various types of authentication methods supported by
/// the library.
abstract class git_credential_t {
  /// A vanilla user/password request
  /// @see git_credential_userpass_plaintext_new
  static const int GIT_CREDENTIAL_USERPASS_PLAINTEXT = 1;

  /// An SSH key-based authentication request
  /// @see git_credential_ssh_key_new
  static const int GIT_CREDENTIAL_SSH_KEY = 2;

  /// An SSH key-based authentication request, with a custom signature
  /// @see git_credential_ssh_custom_new
  static const int GIT_CREDENTIAL_SSH_CUSTOM = 4;

  /// An NTLM/Negotiate-based authentication request.
  /// @see git_credential_default
  static const int GIT_CREDENTIAL_DEFAULT = 8;

  /// An SSH interactive authentication request
  /// @see git_credential_ssh_interactive_new
  static const int GIT_CREDENTIAL_SSH_INTERACTIVE = 16;

  /// Username-only authentication request
  ///
  /// Used as a pre-authentication step if the underlying transport
  /// (eg. SSH, with no username in its URL) does not know which username
  /// to use.
  ///
  /// @see git_credential_username_new
  static const int GIT_CREDENTIAL_USERNAME = 32;

  /// An SSH key-based authentication request
  ///
  /// Allows credentials to be read from memory instead of files.
  /// Note that because of differences in crypto backend support, it might
  /// not be functional.
  ///
  /// @see git_credential_ssh_key_memory_new
  static const int GIT_CREDENTIAL_SSH_MEMORY = 64;
}

/// Callback for the user's custom certificate checks.
///
/// @param cert The host certificate
/// @param valid Whether the libgit2 checks (OpenSSL or WinHTTP) think
/// this certificate is valid
/// @param host Hostname of the host libgit2 connected to
/// @param payload Payload provided by the caller
/// @return 0 to proceed with the connection, < 0 to fail the connection
/// or > 0 to indicate that the callback refused to act and that
/// the existing validity determination should be honored
typedef git_transport_certificate_check_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(ffi.Pointer<git_cert>, ffi.Int32,
            ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Void>)>>;

/// Parent type for `git_cert_hostkey` and `git_cert_x509`.
class git_cert extends ffi.Struct {
  /// Type of certificate. A `GIT_CERT_` value.
  @ffi.Int32()
  external int cert_type;
}

/// Type of host certificate structure that is passed to the check callback
abstract class git_cert_t {
  /// No information about the certificate is available. This may
  /// happen when using curl.
  static const int GIT_CERT_NONE = 0;

  /// The `data` argument to the callback will be a pointer to
  /// the DER-encoded data.
  static const int GIT_CERT_X509 = 1;

  /// The `data` argument to the callback will be a pointer to a
  /// `git_cert_hostkey` structure.
  static const int GIT_CERT_HOSTKEY_LIBSSH2 = 2;

  /// The `data` argument to the callback will be a pointer to a
  /// `git_strarray` with `name:content` strings containing
  /// information about the certificate. This is used when using
  /// curl.
  static const int GIT_CERT_STRARRAY = 3;
}

/// Type for progress callbacks during indexing.  Return a value less
/// than zero to cancel the indexing or download.
///
/// @param stats Structure containing information about the state of the transfer
/// @param payload Payload provided by caller
typedef git_indexer_progress_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(
            ffi.Pointer<git_indexer_progress>, ffi.Pointer<ffi.Void>)>>;

/// This structure is used to provide callers information about the
/// progress of indexing a packfile, either directly or part of a
/// fetch or clone that downloads a packfile.
class git_indexer_progress extends ffi.Struct {
  /// number of objects in the packfile being indexed
  @ffi.Uint32()
  external int total_objects;

  /// received objects that have been hashed
  @ffi.Uint32()
  external int indexed_objects;

  /// received_objects: objects which have been downloaded
  @ffi.Uint32()
  external int received_objects;

  /// locally-available objects that have been injected in order
  /// to fix a thin pack
  @ffi.Uint32()
  external int local_objects;

  /// number of deltas in the packfile being indexed
  @ffi.Uint32()
  external int total_deltas;

  /// received deltas that have been indexed
  @ffi.Uint32()
  external int indexed_deltas;

  /// size of the packfile received up to now
  @ffi.IntPtr()
  external int received_bytes;
}

/// Packbuilder progress notification function
typedef git_packbuilder_progress = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(
            ffi.Int32, ffi.Uint32, ffi.Uint32, ffi.Pointer<ffi.Void>)>>;

/// Push network progress notification function
typedef git_push_transfer_progress_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(
            ffi.Uint32, ffi.Uint32, ffi.IntPtr, ffi.Pointer<ffi.Void>)>>;

/// Callback used to inform of the update status from the remote.
///
/// Called for each updated reference on push. If `status` is
/// not `NULL`, the update was rejected by the remote server
/// and `status` contains the reason given.
///
/// @param refname refname specifying to the remote ref
/// @param status status message sent from the remote
/// @param data data provided by the caller
/// @return 0 on success, otherwise an error
typedef git_push_update_reference_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(ffi.Pointer<ffi.Int8>, ffi.Pointer<ffi.Int8>,
            ffi.Pointer<ffi.Void>)>>;

/// Callback used to inform of upcoming updates.
///
/// @param updates an array containing the updates which will be sent
/// as commands to the destination.
/// @param len number of elements in `updates`
/// @param payload Payload provided by the caller
typedef git_push_negotiation = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(ffi.Pointer<ffi.Pointer<git_push_update>>,
            ffi.IntPtr, ffi.Pointer<ffi.Void>)>>;

/// Represents an update which will be performed on the remote during push
class git_push_update extends ffi.Struct {
  /// The source name of the reference
  external ffi.Pointer<ffi.Int8> src_refname;

  /// The name of the reference to update on the server
  external ffi.Pointer<ffi.Int8> dst_refname;

  /// The current target of the reference
  external git_oid src;

  /// The new target for the reference
  external git_oid dst;
}

/// Signature of a function which creates a transport
typedef git_transport_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(ffi.Pointer<ffi.Pointer<git_transport>>,
            ffi.Pointer<git_remote>, ffi.Pointer<ffi.Void>)>>;

class git_transport extends ffi.Opaque {}

class git_remote extends ffi.Opaque {}

/// Callback invoked immediately before we attempt to connect to the
/// given url.  Callers may change the URL before the connection by
/// calling `git_remote_set_instance_url` in the callback.
///
/// @param remote The remote to be connected
/// @param direction GIT_DIRECTION_FETCH or GIT_DIRECTION_PUSH
/// @param payload Payload provided by the caller
/// @return 0 on success, or an error
typedef git_remote_ready_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(
            ffi.Pointer<git_remote>, ffi.Int32, ffi.Pointer<ffi.Void>)>>;

/// Callback to resolve URLs before connecting to remote
///
/// If you return GIT_PASSTHROUGH, you don't need to write anything to
/// url_resolved.
///
/// @param url_resolved The buffer to write the resolved URL to
/// @param url The URL to resolve
/// @param direction GIT_DIRECTION_FETCH or GIT_DIRECTION_PUSH
/// @param payload Payload provided by the caller
/// @return 0 on success, GIT_PASSTHROUGH or an error
/// @deprecated Use `git_remote_set_instance_url`
typedef git_url_resolve_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(ffi.Pointer<git_buf>, ffi.Pointer<ffi.Int8>,
            ffi.Int32, ffi.Pointer<ffi.Void>)>>;

class git_repository extends ffi.Opaque {}

/// Extended options structure for `git_repository_init_ext`.
///
/// This contains extra options for `git_repository_init_ext` that enable
/// additional initialization features.
class git_repository_init_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Combination of GIT_REPOSITORY_INIT flags above.
  @ffi.Uint32()
  external int flags;

  /// Set to one of the standard GIT_REPOSITORY_INIT_SHARED_... constants
  /// above, or to a custom value that you would like.
  @ffi.Uint32()
  external int mode;

  /// The path to the working dir or NULL for default (i.e. repo_path parent
  /// on non-bare repos). IF THIS IS RELATIVE PATH, IT WILL BE EVALUATED
  /// RELATIVE TO THE REPO_PATH. If this is not the "natural" working
  /// directory, a .git gitlink file will be created here linking to the
  /// repo_path.
  external ffi.Pointer<ffi.Int8> workdir_path;

  /// If set, this will be used to initialize the "description" file in the
  /// repository, instead of using the template content.
  external ffi.Pointer<ffi.Int8> description;

  /// When GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE is set, this contains
  /// the path to use for the template directory. If this is NULL, the config
  /// or default directory options will be used instead.
  external ffi.Pointer<ffi.Int8> template_path;

  /// The name of the head to point HEAD at. If NULL, then this will be
  /// treated as "master" and the HEAD ref will be set to "refs/heads/master".
  /// If this begins with "refs/" it will be used verbatim;
  /// otherwise "refs/heads/" will be prefixed.
  external ffi.Pointer<ffi.Int8> initial_head;

  /// If this is non-NULL, then after the rest of the repository
  /// initialization is completed, an "origin" remote will be added
  /// pointing to this URL.
  external ffi.Pointer<ffi.Int8> origin_url;
}

class git_reference extends ffi.Opaque {}

class git_index extends ffi.Opaque {}

/// Callback used to iterate over each MERGE_HEAD entry
///
/// @see git_repository_mergehead_foreach
///
/// @param oid The merge OID
/// @param payload Payload passed to git_repository_mergehead_foreach
/// @return non-zero to terminate the iteration
typedef git_repository_mergehead_foreach_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Void>)>>;

class git_annotated_commit extends ffi.Opaque {}

class git_object extends ffi.Opaque {}

class git_tree extends ffi.Opaque {}

/// Array of strings
class git_strarray extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<ffi.Int8>> strings;

  @ffi.IntPtr()
  external int count;
}

/// Description of changes to one entry.
///
/// A `delta` is a file pair with an old and new revision.  The old version
/// may be absent if the file was just created and the new version may be
/// absent if the file was deleted.  A diff is mostly just a list of deltas.
///
/// When iterating over a diff, this will be passed to most callbacks and
/// you can use the contents to understand exactly what has changed.
///
/// The `old_file` represents the "from" side of the diff and the `new_file`
/// represents to "to" side of the diff.  What those means depend on the
/// function that was used to generate the diff and will be documented below.
/// You can also use the `GIT_DIFF_REVERSE` flag to flip it around.
///
/// Although the two sides of the delta are named "old_file" and "new_file",
/// they actually may correspond to entries that represent a file, a symbolic
/// link, a submodule commit id, or even a tree (if you are tracking type
/// changes or ignored/untracked directories).
///
/// Under some circumstances, in the name of efficiency, not all fields will
/// be filled in, but we generally try to fill in as much as possible.  One
/// example is that the "flags" field may not have either the `BINARY` or the
/// `NOT_BINARY` flag set to avoid examining file contents if you do not pass
/// in hunk and/or line callbacks to the diff foreach iteration function.  It
/// will just use the git attributes for those files.
///
/// The similarity score is zero unless you call `git_diff_find_similar()`
/// which does a similarity analysis of files in the diff.  Use that
/// function to do rename and copy detection, and to split heavily modified
/// files in add/delete pairs.  After that call, deltas with a status of
/// GIT_DELTA_RENAMED or GIT_DELTA_COPIED will have a similarity score
/// between 0 and 100 indicating how similar the old and new sides are.
///
/// If you ask `git_diff_find_similar` to find heavily modified files to
/// break, but to not *actually* break the records, then GIT_DELTA_MODIFIED
/// records may have a non-zero similarity score if the self-similarity is
/// below the split threshold.  To display this value like core Git, invert
/// the score (a la `printf("M%03d", 100 - delta->similarity)`).
class git_diff_delta extends ffi.Struct {
  @ffi.Int32()
  external int status;

  /// < git_diff_flag_t values
  @ffi.Uint32()
  external int flags;

  /// < for RENAMED and COPIED, value 0-100
  @ffi.Uint16()
  external int similarity;

  /// < number of files in this delta
  @ffi.Uint16()
  external int nfiles;

  external git_diff_file old_file;

  external git_diff_file new_file;
}

/// What type of change is described by a git_diff_delta?
///
/// `GIT_DELTA_RENAMED` and `GIT_DELTA_COPIED` will only show up if you run
/// `git_diff_find_similar()` on the diff object.
///
/// `GIT_DELTA_TYPECHANGE` only shows up given `GIT_DIFF_INCLUDE_TYPECHANGE`
/// in the option flags (otherwise type changes will be split into ADDED /
/// DELETED pairs).
abstract class git_delta_t {
  /// < no changes
  static const int GIT_DELTA_UNMODIFIED = 0;

  /// < entry does not exist in old version
  static const int GIT_DELTA_ADDED = 1;

  /// < entry does not exist in new version
  static const int GIT_DELTA_DELETED = 2;

  /// < entry content changed between old and new
  static const int GIT_DELTA_MODIFIED = 3;

  /// < entry was renamed between old and new
  static const int GIT_DELTA_RENAMED = 4;

  /// < entry was copied from another old entry
  static const int GIT_DELTA_COPIED = 5;

  /// < entry is ignored item in workdir
  static const int GIT_DELTA_IGNORED = 6;

  /// < entry is untracked item in workdir
  static const int GIT_DELTA_UNTRACKED = 7;

  /// < type of entry changed between old and new
  static const int GIT_DELTA_TYPECHANGE = 8;

  /// < entry is unreadable
  static const int GIT_DELTA_UNREADABLE = 9;

  /// < entry in the index is conflicted
  static const int GIT_DELTA_CONFLICTED = 10;
}

/// Description of one side of a delta.
///
/// Although this is called a "file", it could represent a file, a symbolic
/// link, a submodule commit id, or even a tree (although that only if you
/// are tracking type changes or ignored/untracked directories).
class git_diff_file extends ffi.Struct {
  /// The `git_oid` of the item.  If the entry represents an
  /// absent side of a diff (e.g. the `old_file` of a `GIT_DELTA_ADDED` delta),
  /// then the oid will be zeroes.
  external git_oid id;

  /// The NUL-terminated path to the entry relative to the working
  /// directory of the repository.
  external ffi.Pointer<ffi.Int8> path;

  /// The size of the entry in bytes.
  @git_object_size_t()
  external int size;

  /// A combination of the `git_diff_flag_t` types
  @ffi.Uint32()
  external int flags;

  /// Roughly, the stat() `st_mode` value for the item.  This will
  /// be restricted to one of the `git_filemode_t` values.
  @ffi.Uint16()
  external int mode;

  /// Represents the known length of the `id` field, when
  /// converted to a hex string.  It is generally `GIT_OID_HEXSZ`, unless this
  /// delta was created from reading a patch file, in which case it may be
  /// abbreviated to something reasonable, like 7 characters.
  @ffi.Uint16()
  external int id_abbrev;
}

/// The maximum size of an object
typedef git_object_size_t = ffi.Uint64;

/// Checkout behavior flags
///
/// In libgit2, checkout is used to update the working directory and index
/// to match a target tree.  Unlike git checkout, it does not move the HEAD
/// commit for you - use `git_repository_set_head` or the like to do that.
///
/// Checkout looks at (up to) four things: the "target" tree you want to
/// check out, the "baseline" tree of what was checked out previously, the
/// working directory for actual files, and the index for staged changes.
///
/// You give checkout one of three strategies for update:
///
/// - `GIT_CHECKOUT_NONE` is a dry-run strategy that checks for conflicts,
/// etc., but doesn't make any actual changes.
///
/// - `GIT_CHECKOUT_FORCE` is at the opposite extreme, taking any action to
/// make the working directory match the target (including potentially
/// discarding modified files).
///
/// - `GIT_CHECKOUT_SAFE` is between these two options, it will only make
/// modifications that will not lose changes.
///
/// |  target == baseline   |  target != baseline  |
/// ---------------------|-----------------------|----------------------|
/// workdir == baseline |       no action       |  create, update, or  |
/// |                       |     delete file      |
/// ---------------------|-----------------------|----------------------|
/// workdir exists and  |       no action       |   conflict (notify   |
/// is != baseline    | notify dirty MODIFIED | and cancel checkout) |
/// ---------------------|-----------------------|----------------------|
/// workdir missing,   | notify dirty DELETED  |     create file      |
/// baseline present   |                       |                      |
/// ---------------------|-----------------------|----------------------|
///
/// To emulate `git checkout`, use `GIT_CHECKOUT_SAFE` with a checkout
/// notification callback (see below) that displays information about dirty
/// files.  The default behavior will cancel checkout on conflicts.
///
/// To emulate `git checkout-index`, use `GIT_CHECKOUT_SAFE` with a
/// notification callback that cancels the operation if a dirty-but-existing
/// file is found in the working directory.  This core git command isn't
/// quite "force" but is sensitive about some types of changes.
///
/// To emulate `git checkout -f`, use `GIT_CHECKOUT_FORCE`.
///
///
/// There are some additional flags to modify the behavior of checkout:
///
/// - GIT_CHECKOUT_ALLOW_CONFLICTS makes SAFE mode apply safe file updates
/// even if there are conflicts (instead of cancelling the checkout).
///
/// - GIT_CHECKOUT_REMOVE_UNTRACKED means remove untracked files (i.e. not
/// in target, baseline, or index, and not ignored) from the working dir.
///
/// - GIT_CHECKOUT_REMOVE_IGNORED means remove ignored files (that are also
/// untracked) from the working directory as well.
///
/// - GIT_CHECKOUT_UPDATE_ONLY means to only update the content of files that
/// already exist.  Files will not be created nor deleted.  This just skips
/// applying adds, deletes, and typechanges.
///
/// - GIT_CHECKOUT_DONT_UPDATE_INDEX prevents checkout from writing the
/// updated files' information to the index.
///
/// - Normally, checkout will reload the index and git attributes from disk
/// before any operations.  GIT_CHECKOUT_NO_REFRESH prevents this reload.
///
/// - Unmerged index entries are conflicts.  GIT_CHECKOUT_SKIP_UNMERGED skips
/// files with unmerged index entries instead.  GIT_CHECKOUT_USE_OURS and
/// GIT_CHECKOUT_USE_THEIRS to proceed with the checkout using either the
/// stage 2 ("ours") or stage 3 ("theirs") version of files in the index.
///
/// - GIT_CHECKOUT_DONT_OVERWRITE_IGNORED prevents ignored files from being
/// overwritten.  Normally, files that are ignored in the working directory
/// are not considered "precious" and may be overwritten if the checkout
/// target contains that file.
///
/// - GIT_CHECKOUT_DONT_REMOVE_EXISTING prevents checkout from removing
/// files or folders that fold to the same name on case insensitive
/// filesystems.  This can cause files to retain their existing names
/// and write through existing symbolic links.
abstract class git_checkout_strategy_t {
  /// < default is a dry run, no actual updates
  static const int GIT_CHECKOUT_NONE = 0;

  /// Allow safe updates that cannot overwrite uncommitted data.
  /// If the uncommitted changes don't conflict with the checked out files,
  /// the checkout will still proceed, leaving the changes intact.
  ///
  /// Mutually exclusive with GIT_CHECKOUT_FORCE.
  /// GIT_CHECKOUT_FORCE takes precedence over GIT_CHECKOUT_SAFE.
  static const int GIT_CHECKOUT_SAFE = 1;

  /// Allow all updates to force working directory to look like index.
  ///
  /// Mutually exclusive with GIT_CHECKOUT_SAFE.
  /// GIT_CHECKOUT_FORCE takes precedence over GIT_CHECKOUT_SAFE.
  static const int GIT_CHECKOUT_FORCE = 2;

  /// Allow checkout to recreate missing files
  static const int GIT_CHECKOUT_RECREATE_MISSING = 4;

  /// Allow checkout to make safe updates even if conflicts are found
  static const int GIT_CHECKOUT_ALLOW_CONFLICTS = 16;

  /// Remove untracked files not in index (that are not ignored)
  static const int GIT_CHECKOUT_REMOVE_UNTRACKED = 32;

  /// Remove ignored files not in index
  static const int GIT_CHECKOUT_REMOVE_IGNORED = 64;

  /// Only update existing files, don't create new ones
  static const int GIT_CHECKOUT_UPDATE_ONLY = 128;

  /// Normally checkout updates index entries as it goes; this stops that.
  /// Implies `GIT_CHECKOUT_DONT_WRITE_INDEX`.
  static const int GIT_CHECKOUT_DONT_UPDATE_INDEX = 256;

  /// Don't refresh index/config/etc before doing checkout
  static const int GIT_CHECKOUT_NO_REFRESH = 512;

  /// Allow checkout to skip unmerged files
  static const int GIT_CHECKOUT_SKIP_UNMERGED = 1024;

  /// For unmerged files, checkout stage 2 from index
  static const int GIT_CHECKOUT_USE_OURS = 2048;

  /// For unmerged files, checkout stage 3 from index
  static const int GIT_CHECKOUT_USE_THEIRS = 4096;

  /// Treat pathspec as simple list of exact match file paths
  static const int GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH = 8192;

  /// Ignore directories in use, they will be left empty
  static const int GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES = 262144;

  /// Don't overwrite ignored files that exist in the checkout target
  static const int GIT_CHECKOUT_DONT_OVERWRITE_IGNORED = 524288;

  /// Write normal merge files for conflicts
  static const int GIT_CHECKOUT_CONFLICT_STYLE_MERGE = 1048576;

  /// Include common ancestor data in diff3 format files for conflicts
  static const int GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 = 2097152;

  /// Don't overwrite existing files or folders
  static const int GIT_CHECKOUT_DONT_REMOVE_EXISTING = 4194304;

  /// Normally checkout writes the index upon completion; this prevents that.
  static const int GIT_CHECKOUT_DONT_WRITE_INDEX = 8388608;

  /// Show what would be done by a checkout.  Stop after sending
  /// notifications; don't update the working directory or index.
  static const int GIT_CHECKOUT_DRY_RUN = 16777216;

  /// Recursively checkout submodules with same options (NOT IMPLEMENTED)
  static const int GIT_CHECKOUT_UPDATE_SUBMODULES = 65536;

  /// Recursively checkout submodules if HEAD moved in super repo (NOT IMPLEMENTED)
  static const int GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED = 131072;
}

/// Checkout options structure
///
/// Initialize with `GIT_CHECKOUT_OPTIONS_INIT`. Alternatively, you can
/// use `git_checkout_options_init`.
class git_checkout_options extends ffi.Struct {
  /// < The version
  @ffi.Uint32()
  external int version;

  /// < default will be a safe checkout
  @ffi.Uint32()
  external int checkout_strategy;

  /// < don't apply filters like CRLF conversion
  @ffi.Int32()
  external int disable_filters;

  /// < default is 0755
  @ffi.Uint32()
  external int dir_mode;

  /// < default is 0644 or 0755 as dictated by blob
  @ffi.Uint32()
  external int file_mode;

  /// < default is O_CREAT | O_TRUNC | O_WRONLY
  @ffi.Int32()
  external int file_open_flags;

  /// < see `git_checkout_notify_t` above
  @ffi.Uint32()
  external int notify_flags;

  /// Optional callback to get notifications on specific file states.
  /// @see git_checkout_notify_t
  external git_checkout_notify_cb notify_cb;

  /// Payload passed to notify_cb
  external ffi.Pointer<ffi.Void> notify_payload;

  /// Optional callback to notify the consumer of checkout progress.
  external git_checkout_progress_cb progress_cb;

  /// Payload passed to progress_cb
  external ffi.Pointer<ffi.Void> progress_payload;

  /// A list of wildmatch patterns or paths.
  ///
  /// By default, all paths are processed. If you pass an array of wildmatch
  /// patterns, those will be used to filter which paths should be taken into
  /// account.
  ///
  /// Use GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH to treat as a simple list.
  external git_strarray paths;

  /// The expected content of the working directory; defaults to HEAD.
  ///
  /// If the working directory does not match this baseline information,
  /// that will produce a checkout conflict.
  external ffi.Pointer<git_tree> baseline;

  /// Like `baseline` above, though expressed as an index.  This
  /// option overrides `baseline`.
  external ffi.Pointer<git_index> baseline_index;

  /// < alternative checkout path to workdir
  external ffi.Pointer<ffi.Int8> target_directory;

  /// < the name of the common ancestor side of conflicts
  external ffi.Pointer<ffi.Int8> ancestor_label;

  /// < the name of the "our" side of conflicts
  external ffi.Pointer<ffi.Int8> our_label;

  /// < the name of the "their" side of conflicts
  external ffi.Pointer<ffi.Int8> their_label;

  /// Optional callback to notify the consumer of performance data.
  external git_checkout_perfdata_cb perfdata_cb;

  /// Payload passed to perfdata_cb
  external ffi.Pointer<ffi.Void> perfdata_payload;
}

/// Checkout notification callback function
typedef git_checkout_notify_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(
            ffi.Int32,
            ffi.Pointer<ffi.Int8>,
            ffi.Pointer<git_diff_file>,
            ffi.Pointer<git_diff_file>,
            ffi.Pointer<git_diff_file>,
            ffi.Pointer<ffi.Void>)>>;

/// Checkout notification flags
///
/// Checkout will invoke an options notification callback (`notify_cb`) for
/// certain cases - you pick which ones via `notify_flags`:
///
/// Returning a non-zero value from this callback will cancel the checkout.
/// The non-zero return value will be propagated back and returned by the
/// git_checkout_... call.
///
/// Notification callbacks are made prior to modifying any files on disk,
/// so canceling on any notification will still happen prior to any files
/// being modified.
abstract class git_checkout_notify_t {
  static const int GIT_CHECKOUT_NOTIFY_NONE = 0;

  /// Invokes checkout on conflicting paths.
  static const int GIT_CHECKOUT_NOTIFY_CONFLICT = 1;

  /// Notifies about "dirty" files, i.e. those that do not need an update
  /// but no longer match the baseline.  Core git displays these files when
  /// checkout runs, but won't stop the checkout.
  static const int GIT_CHECKOUT_NOTIFY_DIRTY = 2;

  /// Sends notification for any file changed.
  static const int GIT_CHECKOUT_NOTIFY_UPDATED = 4;

  /// Notifies about untracked files.
  static const int GIT_CHECKOUT_NOTIFY_UNTRACKED = 8;

  /// Notifies about ignored files.
  static const int GIT_CHECKOUT_NOTIFY_IGNORED = 16;
  static const int GIT_CHECKOUT_NOTIFY_ALL = 65535;
}

/// Checkout progress notification function
typedef git_checkout_progress_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<ffi.Int8>, ffi.IntPtr, ffi.IntPtr,
            ffi.Pointer<ffi.Void>)>>;

/// Checkout perfdata notification function
typedef git_checkout_perfdata_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<git_checkout_perfdata>, ffi.Pointer<ffi.Void>)>>;

/// Checkout performance-reporting structure
class git_checkout_perfdata extends ffi.Opaque {}

/// Merging options
class git_merge_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// See `git_merge_flag_t` above
  @ffi.Uint32()
  external int flags;

  /// Similarity to consider a file renamed (default 50).  If
  /// `GIT_MERGE_FIND_RENAMES` is enabled, added files will be compared
  /// with deleted files to determine their similarity.  Files that are
  /// more similar than the rename threshold (percentage-wise) will be
  /// treated as a rename.
  @ffi.Uint32()
  external int rename_threshold;

  /// Maximum similarity sources to examine for renames (default 200).
  /// If the number of rename candidates (add / delete pairs) is greater
  /// than this value, inexact rename detection is aborted.
  ///
  /// This setting overrides the `merge.renameLimit` configuration value.
  @ffi.Uint32()
  external int target_limit;

  /// Pluggable similarity metric; pass NULL to use internal metric
  external ffi.Pointer<git_diff_similarity_metric> metric;

  /// Maximum number of times to merge common ancestors to build a
  /// virtual merge base when faced with criss-cross merges.  When this
  /// limit is reached, the next ancestor will simply be used instead of
  /// attempting to merge it.  The default is unlimited.
  @ffi.Uint32()
  external int recursion_limit;

  /// Default merge driver to be used when both sides of a merge have
  /// changed.  The default is the `text` driver.
  external ffi.Pointer<ffi.Int8> default_driver;

  /// Flags for handling conflicting content, to be used with the standard
  /// (`text`) merge driver.
  @ffi.Int32()
  external int file_favor;

  /// see `git_merge_file_flag_t` above
  @ffi.Uint32()
  external int file_flags;
}

/// Pluggable similarity metric
class git_diff_similarity_metric extends ffi.Opaque {}

/// Merge file favor options for `git_merge_options` instruct the file-level
/// merging functionality how to deal with conflicting regions of the files.
abstract class git_merge_file_favor_t {
  /// When a region of a file is changed in both branches, a conflict
  /// will be recorded in the index so that `git_checkout` can produce
  /// a merge file with conflict markers in the working directory.
  /// This is the default.
  static const int GIT_MERGE_FILE_FAVOR_NORMAL = 0;

  /// When a region of a file is changed in both branches, the file
  /// created in the index will contain the "ours" side of any conflicting
  /// region.  The index will not record a conflict.
  static const int GIT_MERGE_FILE_FAVOR_OURS = 1;

  /// When a region of a file is changed in both branches, the file
  /// created in the index will contain the "theirs" side of any conflicting
  /// region.  The index will not record a conflict.
  static const int GIT_MERGE_FILE_FAVOR_THEIRS = 2;

  /// When a region of a file is changed in both branches, the file
  /// created in the index will contain each unique line from each side,
  /// which has the result of combining both files.  The index will not
  /// record a conflict.
  static const int GIT_MERGE_FILE_FAVOR_UNION = 3;
}

/// The results of `git_merge_analysis` indicate the merge opportunities.
abstract class git_merge_analysis_t {
  /// No merge is possible.  (Unused.)
  static const int GIT_MERGE_ANALYSIS_NONE = 0;

  /// A "normal" merge; both HEAD and the given merge input have diverged
  /// from their common ancestor.  The divergent commits must be merged.
  static const int GIT_MERGE_ANALYSIS_NORMAL = 1;

  /// All given merge inputs are reachable from HEAD, meaning the
  /// repository is up-to-date and no merge needs to be performed.
  static const int GIT_MERGE_ANALYSIS_UP_TO_DATE = 2;

  /// The given merge input is a fast-forward from HEAD and no merge
  /// needs to be performed.  Instead, the client can check out the
  /// given merge input.
  static const int GIT_MERGE_ANALYSIS_FASTFORWARD = 4;

  /// The HEAD of the current repository is "unborn" and does not point to
  /// a valid commit.  No merge can be performed, but the caller may wish
  /// to simply set HEAD to the target commit(s).
  static const int GIT_MERGE_ANALYSIS_UNBORN = 8;
}

/// The user's stated preference for merges.
abstract class git_merge_preference_t {
  /// No configuration was found that suggests a preferred behavior for
  /// merge.
  static const int GIT_MERGE_PREFERENCE_NONE = 0;

  /// There is a `merge.ff=false` configuration setting, suggesting that
  /// the user does not want to allow a fast-forward merge.
  static const int GIT_MERGE_PREFERENCE_NO_FASTFORWARD = 1;

  /// There is a `merge.ff=only` configuration setting, suggesting that
  /// the user only wants fast-forward merges.
  static const int GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY = 2;
}

/// Fetch options structure.
///
/// Zero out for defaults.  Initialize with `GIT_FETCH_OPTIONS_INIT` macro to
/// correctly set the `version` field.  E.g.
///
/// git_fetch_options opts = GIT_FETCH_OPTIONS_INIT;
class git_fetch_options extends ffi.Struct {
  @ffi.Int32()
  external int version;

  /// Callbacks to use for this fetch operation
  external git_remote_callbacks callbacks;

  /// Whether to perform a prune after the fetch
  @ffi.Int32()
  external int prune;

  /// Whether to write the results to FETCH_HEAD. Defaults to
  /// on. Leave this default in order to behave like git.
  @ffi.Int32()
  external int update_fetchhead;

  /// Determines how to behave regarding tags on the remote, such
  /// as auto-downloading tags for objects we're downloading or
  /// downloading all of them.
  ///
  /// The default is to auto-follow tags.
  @ffi.Int32()
  external int download_tags;

  /// Proxy options to use, by default no proxy is used.
  external git_proxy_options proxy_opts;

  /// Extra headers for this fetch operation
  external git_strarray custom_headers;
}

/// Acceptable prune settings when fetching
abstract class git_fetch_prune_t {
  /// Use the setting from the configuration
  static const int GIT_FETCH_PRUNE_UNSPECIFIED = 0;

  /// Force pruning on
  static const int GIT_FETCH_PRUNE = 1;

  /// Force pruning off
  static const int GIT_FETCH_NO_PRUNE = 2;
}

/// Automatic tag following option
///
/// Lets us select the --tags option to use.
abstract class git_remote_autotag_option_t {
  /// Use the setting from the configuration.
  static const int GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED = 0;

  /// Ask the server for tags pointing to objects we're already
  /// downloading.
  static const int GIT_REMOTE_DOWNLOAD_TAGS_AUTO = 1;

  /// Don't ask for any tags beyond the refspecs.
  static const int GIT_REMOTE_DOWNLOAD_TAGS_NONE = 2;

  /// Ask for the all the tags.
  static const int GIT_REMOTE_DOWNLOAD_TAGS_ALL = 3;
}

/// Options for connecting through a proxy
///
/// Note that not all types may be supported, depending on the platform
/// and compilation options.
class git_proxy_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// The type of proxy to use, by URL, auto-detect.
  @ffi.Int32()
  external int type;

  /// The URL of the proxy.
  external ffi.Pointer<ffi.Int8> url;

  /// This will be called if the remote host requires
  /// authentication in order to connect to it.
  ///
  /// Returning GIT_PASSTHROUGH will make libgit2 behave as
  /// though this field isn't set.
  external git_credential_acquire_cb credentials;

  /// If cert verification fails, this will be called to let the
  /// user make the final decision of whether to allow the
  /// connection to proceed. Returns 0 to allow the connection
  /// or a negative value to indicate an error.
  external git_transport_certificate_check_cb certificate_check;

  /// Payload to be provided to the credentials and certificate
  /// check callbacks.
  external ffi.Pointer<ffi.Void> payload;
}

/// The type of proxy to use.
abstract class git_proxy_t {
  /// Do not attempt to connect through a proxy
  ///
  /// If built against libcurl, it itself may attempt to connect
  /// to a proxy if the environment variables specify it.
  static const int GIT_PROXY_NONE = 0;

  /// Try to auto-detect the proxy from the git configuration.
  static const int GIT_PROXY_AUTO = 1;

  /// Connect via the URL given in the options
  static const int GIT_PROXY_SPECIFIED = 2;
}

/// Controls the behavior of a git_push object.
class git_push_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// If the transport being used to push to the remote requires the creation
  /// of a pack file, this controls the number of worker threads used by
  /// the packbuilder when creating that pack file to be sent to the remote.
  ///
  /// If set to 0, the packbuilder will auto-detect the number of threads
  /// to create. The default value is 1.
  @ffi.Uint32()
  external int pb_parallelism;

  /// Callbacks to use for this push operation
  external git_remote_callbacks callbacks;

  /// Proxy options to use, by default no proxy is used.
  external git_proxy_options proxy_opts;

  /// Extra headers for this push operation
  external git_strarray custom_headers;
}

/// Clone options structure
///
/// Initialize with `GIT_CLONE_OPTIONS_INIT`. Alternatively, you can
/// use `git_clone_options_init`.
class git_clone_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// These options are passed to the checkout step. To disable
  /// checkout, set the `checkout_strategy` to
  /// `GIT_CHECKOUT_NONE`.
  external git_checkout_options checkout_opts;

  /// Options which control the fetch, including callbacks.
  ///
  /// The callbacks are used for reporting fetch progress, and for acquiring
  /// credentials in the event they are needed.
  external git_fetch_options fetch_opts;

  /// Set to zero (false) to create a standard repo, or non-zero
  /// for a bare repo
  @ffi.Int32()
  external int bare;

  /// Whether to use a fetch or copy the object database.
  @ffi.Int32()
  external int local;

  /// The name of the branch to checkout. NULL means use the
  /// remote's default branch.
  external ffi.Pointer<ffi.Int8> checkout_branch;

  /// A callback used to create the new repository into which to
  /// clone. If NULL, the 'bare' field will be used to determine
  /// whether to create a bare repository.
  external git_repository_create_cb repository_cb;

  /// An opaque payload to pass to the git_repository creation callback.
  /// This parameter is ignored unless repository_cb is non-NULL.
  external ffi.Pointer<ffi.Void> repository_cb_payload;

  /// A callback used to create the git_remote, prior to its being
  /// used to perform the clone operation. See the documentation for
  /// git_remote_create_cb for details. This parameter may be NULL,
  /// indicating that git_clone should provide default behavior.
  external git_remote_create_cb remote_cb;

  /// An opaque payload to pass to the git_remote creation callback.
  /// This parameter is ignored unless remote_cb is non-NULL.
  external ffi.Pointer<ffi.Void> remote_cb_payload;
}

/// Options for bypassing the git-aware transport on clone. Bypassing
/// it means that instead of a fetch, libgit2 will copy the object
/// database directory instead of figuring out what it needs, which is
/// faster. If possible, it will hardlink the files to save space.
abstract class git_clone_local_t {
  /// Auto-detect (default), libgit2 will bypass the git-aware
  /// transport for local paths, but use a normal fetch for
  /// `file://` urls.
  static const int GIT_CLONE_LOCAL_AUTO = 0;

  /// Bypass the git-aware transport even for a `file://` url.
  static const int GIT_CLONE_LOCAL = 1;

  /// Do no bypass the git-aware transport
  static const int GIT_CLONE_NO_LOCAL = 2;

  /// Bypass the git-aware transport, but do not try to use
  /// hardlinks.
  static const int GIT_CLONE_LOCAL_NO_LINKS = 3;
}

/// The signature of a function matchin git_repository_init, with an
/// aditional void * as callback payload.
///
/// Callers of git_clone my provide a function matching this signature
/// to override the repository creation and customization process
/// during a clone operation.
///
/// @param out the resulting repository
/// @param path path in which to create the repository
/// @param bare whether the repository is bare. This is the value from the clone options
/// @param payload payload specified by the options
/// @return 0, or a negative value to indicate error
typedef git_repository_create_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(ffi.Pointer<ffi.Pointer<git_repository>>,
            ffi.Pointer<ffi.Int8>, ffi.Int32, ffi.Pointer<ffi.Void>)>>;

/// The signature of a function matching git_remote_create, with an additional
/// void* as a callback payload.
///
/// Callers of git_clone may provide a function matching this signature to override
/// the remote creation and customization process during a clone operation.
///
/// @param out the resulting remote
/// @param repo the repository in which to create the remote
/// @param name the remote's name
/// @param url the remote's url
/// @param payload an opaque payload
/// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
typedef git_remote_create_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int32 Function(
            ffi.Pointer<ffi.Pointer<git_remote>>,
            ffi.Pointer<git_repository>,
            ffi.Pointer<ffi.Int8>,
            ffi.Pointer<ffi.Int8>,
            ffi.Pointer<ffi.Void>)>>;

class git_commit extends ffi.Opaque {}

/// Structure to store extra details of the last error that occurred.
///
/// This is kept on a per-thread basis if GIT_THREADS was defined when the
/// library was build, otherwise one is kept globally for the library
class git_error extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> message;

  @ffi.Int32()
  external int klass;
}

/// Select the files on which to report status.
///
/// With `git_status_foreach_ext`, this will control which changes get
/// callbacks.  With `git_status_list_new`, these will control which
/// changes are included in the list.
abstract class git_status_show_t {
  /// The default. This roughly matches `git status --porcelain` regarding
  /// which files are included and in what order.
  static const int GIT_STATUS_SHOW_INDEX_AND_WORKDIR = 0;

  /// Only gives status based on HEAD to index comparison, not looking at
  /// working directory changes.
  static const int GIT_STATUS_SHOW_INDEX_ONLY = 1;

  /// Only gives status based on index to working directory comparison,
  /// not comparing the index to the HEAD.
  static const int GIT_STATUS_SHOW_WORKDIR_ONLY = 2;
}

/// Flags to control status callbacks
///
/// Calling `git_status_foreach()` is like calling the extended version
/// with: GIT_STATUS_OPT_INCLUDE_IGNORED, GIT_STATUS_OPT_INCLUDE_UNTRACKED,
/// and GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS.  Those options are bundled
/// together as `GIT_STATUS_OPT_DEFAULTS` if you want them as a baseline.
abstract class git_status_opt_t {
  /// Says that callbacks should be made on untracked files.
  /// These will only be made if the workdir files are included in the status
  /// "show" option.
  static const int GIT_STATUS_OPT_INCLUDE_UNTRACKED = 1;

  /// Says that ignored files get callbacks.
  /// Again, these callbacks will only be made if the workdir files are
  /// included in the status "show" option.
  static const int GIT_STATUS_OPT_INCLUDE_IGNORED = 2;

  /// Indicates that callback should be made even on unmodified files.
  static const int GIT_STATUS_OPT_INCLUDE_UNMODIFIED = 4;

  /// Indicates that submodules should be skipped.
  /// This only applies if there are no pending typechanges to the submodule
  /// (either from or to another type).
  static const int GIT_STATUS_OPT_EXCLUDE_SUBMODULES = 8;

  /// Indicates that all files in untracked directories should be included.
  /// Normally if an entire directory is new, then just the top-level
  /// directory is included (with a trailing slash on the entry name).
  /// This flag says to include all of the individual files in the directory
  /// instead.
  static const int GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS = 16;

  /// Indicates that the given path should be treated as a literal path,
  /// and not as a pathspec pattern.
  static const int GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH = 32;

  /// Indicates that the contents of ignored directories should be included
  /// in the status. This is like doing `git ls-files -o -i --exclude-standard`
  /// with core git.
  static const int GIT_STATUS_OPT_RECURSE_IGNORED_DIRS = 64;

  /// Indicates that rename detection should be processed between the head and
  /// the index and enables the GIT_STATUS_INDEX_RENAMED as a possible status
  /// flag.
  static const int GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX = 128;

  /// Indicates that rename detection should be run between the index and the
  /// working directory and enabled GIT_STATUS_WT_RENAMED as a possible status
  /// flag.
  static const int GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR = 256;

  /// Overrides the native case sensitivity for the file system and forces
  /// the output to be in case-sensitive order.
  static const int GIT_STATUS_OPT_SORT_CASE_SENSITIVELY = 512;

  /// Overrides the native case sensitivity for the file system and forces
  /// the output to be in case-insensitive order.
  static const int GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY = 1024;

  /// Iindicates that rename detection should include rewritten files.
  static const int GIT_STATUS_OPT_RENAMES_FROM_REWRITES = 2048;

  /// Bypasses the default status behavior of doing a "soft" index reload
  /// (i.e. reloading the index data if the file on disk has been modified
  /// outside libgit2).
  static const int GIT_STATUS_OPT_NO_REFRESH = 4096;

  /// Tells libgit2 to refresh the stat cache in the index for files that are
  /// unchanged but have out of date stat einformation in the index.
  /// It will result in less work being done on subsequent calls to get status.
  /// This is mutually exclusive with the NO_REFRESH option.
  static const int GIT_STATUS_OPT_UPDATE_INDEX = 8192;

  /// Normally files that cannot be opened or read are ignored as
  /// these are often transient files; this option will return
  /// unreadable files as `GIT_STATUS_WT_UNREADABLE`.
  static const int GIT_STATUS_OPT_INCLUDE_UNREADABLE = 16384;

  /// Unreadable files will be detected and given the status
  /// untracked instead of unreadable.
  static const int GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED = 32768;
}

/// Options to control how `git_status_foreach_ext()` will issue callbacks.
///
/// Initialize with `GIT_STATUS_OPTIONS_INIT`. Alternatively, you can
/// use `git_status_options_init`.
class git_status_options extends ffi.Struct {
  /// The struct version; pass `GIT_STATUS_OPTIONS_VERSION`.
  @ffi.Uint32()
  external int version;

  /// The `show` value is one of the `git_status_show_t` constants that
  /// control which files to scan and in what order.
  @ffi.Int32()
  external int show1;

  /// The `flags` value is an OR'ed combination of the
  /// `git_status_opt_t` values above.
  @ffi.Uint32()
  external int flags;

  /// The `pathspec` is an array of path patterns to match (using
  /// fnmatch-style matching), or just an array of paths to match
  /// exactly if `GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH` is specified
  /// in the flags.
  external git_strarray pathspec;

  /// The `baseline` is the tree to be used for comparison to the
  /// working directory and index; defaults to HEAD.
  external ffi.Pointer<git_tree> baseline;
}

/// A status entry, providing the differences between the file as it exists
/// in HEAD and the index, and providing the differences between the index
/// and the working directory.
///
/// The `status` value provides the status flags for this file.
///
/// The `head_to_index` value provides detailed information about the
/// differences between the file in HEAD and the file in the index.
///
/// The `index_to_workdir` value provides detailed information about the
/// differences between the file in the index and the file in the
/// working directory.
class git_status_entry extends ffi.Struct {
  @ffi.Int32()
  external int status;

  external ffi.Pointer<git_diff_delta> head_to_index;

  external ffi.Pointer<git_diff_delta> index_to_workdir;
}

/// Status flags for a single file.
///
/// A combination of these values will be returned to indicate the status of
/// a file.  Status compares the working directory, the index, and the
/// current HEAD of the repository.  The `GIT_STATUS_INDEX` set of flags
/// represents the status of file in the index relative to the HEAD, and the
/// `GIT_STATUS_WT` set of flags represent the status of the file in the
/// working directory relative to the index.
abstract class git_status_t {
  static const int GIT_STATUS_CURRENT = 0;
  static const int GIT_STATUS_INDEX_NEW = 1;
  static const int GIT_STATUS_INDEX_MODIFIED = 2;
  static const int GIT_STATUS_INDEX_DELETED = 4;
  static const int GIT_STATUS_INDEX_RENAMED = 8;
  static const int GIT_STATUS_INDEX_TYPECHANGE = 16;
  static const int GIT_STATUS_WT_NEW = 128;
  static const int GIT_STATUS_WT_MODIFIED = 256;
  static const int GIT_STATUS_WT_DELETED = 512;
  static const int GIT_STATUS_WT_TYPECHANGE = 1024;
  static const int GIT_STATUS_WT_RENAMED = 2048;
  static const int GIT_STATUS_WT_UNREADABLE = 4096;
  static const int GIT_STATUS_IGNORED = 16384;
  static const int GIT_STATUS_CONFLICTED = 32768;
}

class git_status_list extends ffi.Opaque {}

const int GIT_REPOSITORY_INIT_OPTIONS_VERSION = 1;

const int GIT_CHECKOUT_OPTIONS_VERSION = 1;

const int GIT_MERGE_OPTIONS_VERSION = 1;

const int GIT_FETCH_OPTIONS_VERSION = 1;

const int GIT_PUSH_OPTIONS_VERSION = 1;

const int GIT_CLONE_OPTIONS_VERSION = 1;

const int GIT_STATUS_OPTIONS_VERSION = 1;
