// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for libgit2
class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Query compile time options for libgit2.
  ///
  /// @return A combination of GIT_FEATURE_* values.
  ///
  /// - GIT_FEATURE_THREADS
  /// Libgit2 was compiled with thread support. Note that thread support is
  /// still to be seen as a 'work in progress' - basic object lookups are
  /// believed to be threadsafe, but other operations may not be.
  ///
  /// - GIT_FEATURE_HTTPS
  /// Libgit2 supports the https:// protocol. This requires the openssl
  /// library to be found when compiling libgit2.
  ///
  /// - GIT_FEATURE_SSH
  /// Libgit2 supports the SSH protocol for network operations. This requires
  /// the libssh2 library to be found when compiling libgit2
  int libgit2_features() {
    return _libgit2_features();
  }

  late final _libgit2_features_ptr =
      _lookup<ffi.NativeFunction<_c_libgit2_features>>('git_libgit2_features');
  late final _dart_libgit2_features _libgit2_features =
      _libgit2_features_ptr.asFunction<_dart_libgit2_features>();

  /// Free the memory referred to by the git_buf.
  ///
  /// Note that this does not free the `git_buf` itself, just the memory
  /// pointed to by `buffer->ptr`.  This will not free the memory if it looks
  /// like it was not allocated internally, but it will clear the buffer back
  /// to the empty state.
  ///
  /// @param buffer The buffer to deallocate
  void buf_dispose(
    ffi.Pointer<git_buf> buffer,
  ) {
    return _buf_dispose(
      buffer,
    );
  }

  late final _buf_dispose_ptr =
      _lookup<ffi.NativeFunction<_c_buf_dispose>>('git_buf_dispose');
  late final _dart_buf_dispose _buf_dispose =
      _buf_dispose_ptr.asFunction<_dart_buf_dispose>();

  /// Copy an oid from one structure to another.
  ///
  /// @param out oid structure the result is written into.
  /// @param src oid structure to copy from.
  /// @return 0 on success or error code
  int oid_cpy(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_oid> src,
  ) {
    return _oid_cpy(
      out,
      src,
    );
  }

  late final _oid_cpy_ptr =
      _lookup<ffi.NativeFunction<_c_oid_cpy>>('git_oid_cpy');
  late final _dart_oid_cpy _oid_cpy = _oid_cpy_ptr.asFunction<_dart_oid_cpy>();

  /// Open a git repository.
  ///
  /// The 'path' argument must point to either a git repository
  /// folder, or an existing work dir.
  ///
  /// The method will automatically detect if 'path' is a normal
  /// or bare repository or fail is 'path' is neither.
  ///
  /// @param out pointer to the repo which will be opened
  /// @param path the path to the repository
  /// @return 0 or an error code
  int repository_open(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _repository_open(
      out,
      path,
    );
  }

  late final _repository_open_ptr =
      _lookup<ffi.NativeFunction<_c_repository_open>>('git_repository_open');
  late final _dart_repository_open _repository_open =
      _repository_open_ptr.asFunction<_dart_repository_open>();

  /// Free a previously allocated repository
  ///
  /// Note that after a repository is free'd, all the objects it has spawned
  /// will still exist until they are manually closed by the user
  /// with `git_object_free`, but accessing any of the attributes of
  /// an object without a backing repository will result in undefined
  /// behavior
  ///
  /// @param repo repository handle to close. If NULL nothing occurs.
  void repository_free(
    ffi.Pointer<git_repository> repo,
  ) {
    return _repository_free(
      repo,
    );
  }

  late final _repository_free_ptr =
      _lookup<ffi.NativeFunction<_c_repository_free>>('git_repository_free');
  late final _dart_repository_free _repository_free =
      _repository_free_ptr.asFunction<_dart_repository_free>();

  /// Creates a new Git repository in the given folder.
  ///
  /// TODO:
  /// - Reinit the repository
  ///
  /// @param out pointer to the repo which will be created or reinitialized
  /// @param path the path to the repository
  /// @param is_bare if true, a Git repository without a working directory is
  /// created at the pointed path. If false, provided path will be
  /// considered as the working directory into which the .git directory
  /// will be created.
  ///
  /// @return 0 or an error code
  int repository_init(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> path,
    int is_bare,
  ) {
    return _repository_init(
      out,
      path,
      is_bare,
    );
  }

  late final _repository_init_ptr =
      _lookup<ffi.NativeFunction<_c_repository_init>>('git_repository_init');
  late final _dart_repository_init _repository_init =
      _repository_init_ptr.asFunction<_dart_repository_init>();

  /// Initialize git_repository_init_options structure
  ///
  /// Initializes a `git_repository_init_options` with default values. Equivalent to
  /// creating an instance with `GIT_REPOSITORY_INIT_OPTIONS_INIT`.
  ///
  /// @param opts The `git_repository_init_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REPOSITORY_INIT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int repository_init_options_init(
    ffi.Pointer<git_repository_init_options> opts,
    int version,
  ) {
    return _repository_init_options_init(
      opts,
      version,
    );
  }

  late final _repository_init_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_repository_init_options_init>>(
          'git_repository_init_options_init');
  late final _dart_repository_init_options_init _repository_init_options_init =
      _repository_init_options_init_ptr
          .asFunction<_dart_repository_init_options_init>();

  /// Create a new Git repository in the given folder with extended controls.
  ///
  /// This will initialize a new git repository (creating the repo_path
  /// if requested by flags) and working directory as needed.  It will
  /// auto-detect the case sensitivity of the file system and if the
  /// file system supports file mode bits correctly.
  ///
  /// @param out Pointer to the repo which will be created or reinitialized.
  /// @param repo_path The path to the repository.
  /// @param opts Pointer to git_repository_init_options struct.
  /// @return 0 or an error code on failure.
  int repository_init_ext(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> repo_path,
    ffi.Pointer<git_repository_init_options> opts,
  ) {
    return _repository_init_ext(
      out,
      repo_path,
      opts,
    );
  }

  late final _repository_init_ext_ptr =
      _lookup<ffi.NativeFunction<_c_repository_init_ext>>(
          'git_repository_init_ext');
  late final _dart_repository_init_ext _repository_init_ext =
      _repository_init_ext_ptr.asFunction<_dart_repository_init_ext>();

  /// Retrieve and resolve the reference pointed at by HEAD.
  ///
  /// The returned `git_reference` will be owned by caller and
  /// `git_reference_free()` must be called when done with it to release the
  /// allocated memory and prevent a leak.
  ///
  /// @param out pointer to the reference which will be retrieved
  /// @param repo a repository object
  ///
  /// @return 0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing
  /// branch, GIT_ENOTFOUND when HEAD is missing; an error code otherwise
  int repository_head(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _repository_head(
      out,
      repo,
    );
  }

  late final _repository_head_ptr =
      _lookup<ffi.NativeFunction<_c_repository_head>>('git_repository_head');
  late final _dart_repository_head _repository_head =
      _repository_head_ptr.asFunction<_dart_repository_head>();

  /// Check if the current branch is unborn
  ///
  /// An unborn branch is one named from HEAD but which doesn't exist in
  /// the refs namespace, because it doesn't have any commit to point to.
  ///
  /// @param repo Repo to test
  /// @return 1 if the current branch is unborn, 0 if it's not; error
  /// code if there was an error
  int repository_head_unborn(
    ffi.Pointer<git_repository> repo,
  ) {
    return _repository_head_unborn(
      repo,
    );
  }

  late final _repository_head_unborn_ptr =
      _lookup<ffi.NativeFunction<_c_repository_head_unborn>>(
          'git_repository_head_unborn');
  late final _dart_repository_head_unborn _repository_head_unborn =
      _repository_head_unborn_ptr.asFunction<_dart_repository_head_unborn>();

  /// Get the Index file for this repository.
  ///
  /// If a custom index has not been set, the default
  /// index for the repository will be returned (the one
  /// located in `.git/index`).
  ///
  /// The index must be freed once it's no longer being used by
  /// the user.
  ///
  /// @param out Pointer to store the loaded index
  /// @param repo A repository object
  /// @return 0, or an error code
  int repository_index(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _repository_index(
      out,
      repo,
    );
  }

  late final _repository_index_ptr =
      _lookup<ffi.NativeFunction<_c_repository_index>>('git_repository_index');
  late final _dart_repository_index _repository_index =
      _repository_index_ptr.asFunction<_dart_repository_index>();

  /// Remove all the metadata associated with an ongoing command like merge,
  /// revert, cherry-pick, etc.  For example: MERGE_HEAD, MERGE_MSG, etc.
  ///
  /// @param repo A repository object
  /// @return 0 on success, or error
  int repository_state_cleanup(
    ffi.Pointer<git_repository> repo,
  ) {
    return _repository_state_cleanup(
      repo,
    );
  }

  late final _repository_state_cleanup_ptr =
      _lookup<ffi.NativeFunction<_c_repository_state_cleanup>>(
          'git_repository_state_cleanup');
  late final _dart_repository_state_cleanup _repository_state_cleanup =
      _repository_state_cleanup_ptr
          .asFunction<_dart_repository_state_cleanup>();

  /// If a merge is in progress, invoke 'callback' for each commit ID in the
  /// MERGE_HEAD file.
  ///
  /// Return a non-zero value from the callback to stop the loop.
  ///
  /// @param repo A repository object
  /// @param callback Callback function
  /// @param payload Pointer to callback data (optional)
  /// @return 0 on success, non-zero callback return value, GIT_ENOTFOUND if
  /// there is no MERGE_HEAD file, or other error code.
  int repository_mergehead_foreach(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.NativeFunction<git_repository_mergehead_foreach_cb>>
        callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _repository_mergehead_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _repository_mergehead_foreach_ptr =
      _lookup<ffi.NativeFunction<_c_repository_mergehead_foreach>>(
          'git_repository_mergehead_foreach');
  late final _dart_repository_mergehead_foreach _repository_mergehead_foreach =
      _repository_mergehead_foreach_ptr
          .asFunction<_dart_repository_mergehead_foreach>();

  /// Make the repository HEAD point to the specified reference.
  ///
  /// If the provided reference points to a Tree or a Blob, the HEAD is
  /// unaltered and -1 is returned.
  ///
  /// If the provided reference points to a branch, the HEAD will point
  /// to that branch, staying attached, or become attached if it isn't yet.
  /// If the branch doesn't exist yet, no error will be return. The HEAD
  /// will then be attached to an unborn branch.
  ///
  /// Otherwise, the HEAD will be detached and will directly point to
  /// the Commit.
  ///
  /// @param repo Repository pointer
  /// @param refname Canonical name of the reference the HEAD should point at
  /// @return 0 on success, or an error code
  int repository_set_head(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> refname,
  ) {
    return _repository_set_head(
      repo,
      refname,
    );
  }

  late final _repository_set_head_ptr =
      _lookup<ffi.NativeFunction<_c_repository_set_head>>(
          'git_repository_set_head');
  late final _dart_repository_set_head _repository_set_head =
      _repository_set_head_ptr.asFunction<_dart_repository_set_head>();

  /// Determines the status of a git repository - ie, whether an operation
  /// (merge, cherry-pick, etc) is in progress.
  ///
  /// @param repo Repository pointer
  /// @return The state of the repository
  int repository_state(
    ffi.Pointer<git_repository> repo,
  ) {
    return _repository_state(
      repo,
    );
  }

  late final _repository_state_ptr =
      _lookup<ffi.NativeFunction<_c_repository_state>>('git_repository_state');
  late final _dart_repository_state _repository_state =
      _repository_state_ptr.asFunction<_dart_repository_state>();

  /// Creates a `git_annotated_commit` from the given reference.
  /// The resulting git_annotated_commit must be freed with
  /// `git_annotated_commit_free`.
  ///
  /// @param out pointer to store the git_annotated_commit result in
  /// @param repo repository that contains the given reference
  /// @param ref reference to use to lookup the git_annotated_commit
  /// @return 0 on success or error code
  int annotated_commit_from_ref(
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_reference> ref,
  ) {
    return _annotated_commit_from_ref(
      out,
      repo,
      ref,
    );
  }

  late final _annotated_commit_from_ref_ptr =
      _lookup<ffi.NativeFunction<_c_annotated_commit_from_ref>>(
          'git_annotated_commit_from_ref');
  late final _dart_annotated_commit_from_ref _annotated_commit_from_ref =
      _annotated_commit_from_ref_ptr
          .asFunction<_dart_annotated_commit_from_ref>();

  /// Gets the commit ID that the given `git_annotated_commit` refers to.
  ///
  /// @param commit the given annotated commit
  /// @return commit id
  ffi.Pointer<git_oid> annotated_commit_id(
    ffi.Pointer<git_annotated_commit> commit,
  ) {
    return _annotated_commit_id(
      commit,
    );
  }

  late final _annotated_commit_id_ptr =
      _lookup<ffi.NativeFunction<_c_annotated_commit_id>>(
          'git_annotated_commit_id');
  late final _dart_annotated_commit_id _annotated_commit_id =
      _annotated_commit_id_ptr.asFunction<_dart_annotated_commit_id>();

  /// Frees a `git_annotated_commit`.
  ///
  /// @param commit annotated commit to free
  void annotated_commit_free(
    ffi.Pointer<git_annotated_commit> commit,
  ) {
    return _annotated_commit_free(
      commit,
    );
  }

  late final _annotated_commit_free_ptr =
      _lookup<ffi.NativeFunction<_c_annotated_commit_free>>(
          'git_annotated_commit_free');
  late final _dart_annotated_commit_free _annotated_commit_free =
      _annotated_commit_free_ptr.asFunction<_dart_annotated_commit_free>();

  /// Lookup a tree object from the repository.
  ///
  /// @param out Pointer to the looked up tree
  /// @param repo The repo to use when locating the tree.
  /// @param id Identity of the tree to locate.
  /// @return 0 or an error code
  int tree_lookup(
    ffi.Pointer<ffi.Pointer<git_tree>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _tree_lookup(
      out,
      repo,
      id,
    );
  }

  late final _tree_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_tree_lookup>>('git_tree_lookup');
  late final _dart_tree_lookup _tree_lookup =
      _tree_lookup_ptr.asFunction<_dart_tree_lookup>();

  /// Close an open tree
  ///
  /// You can no longer use the git_tree pointer after this call.
  ///
  /// IMPORTANT: You MUST call this method when you stop using a tree to
  /// release memory. Failure to do so will cause a memory leak.
  ///
  /// @param tree The tree to close
  void tree_free(
    ffi.Pointer<git_tree> tree,
  ) {
    return _tree_free(
      tree,
    );
  }

  late final _tree_free_ptr =
      _lookup<ffi.NativeFunction<_c_tree_free>>('git_tree_free');
  late final _dart_tree_free _tree_free =
      _tree_free_ptr.asFunction<_dart_tree_free>();

  /// Free the strings contained in a string array.  This method should
  /// be called on `git_strarray` objects that were provided by the
  /// library.  Not doing so, will result in a memory leak.
  ///
  /// This does not free the `git_strarray` itself, since the library will
  /// never allocate that object directly itself.
  ///
  /// @param array The git_strarray that contains strings to free
  void strarray_dispose(
    ffi.Pointer<git_strarray> array,
  ) {
    return _strarray_dispose(
      array,
    );
  }

  late final _strarray_dispose_ptr =
      _lookup<ffi.NativeFunction<_c_strarray_dispose>>('git_strarray_dispose');
  late final _dart_strarray_dispose _strarray_dispose =
      _strarray_dispose_ptr.asFunction<_dart_strarray_dispose>();

  /// Lookup a reference by name and resolve immediately to OID.
  ///
  /// This function provides a quick way to resolve a reference name straight
  /// through to the object id that it refers to.  This avoids having to
  /// allocate or free any `git_reference` objects for simple situations.
  ///
  /// The name will be checked for validity.
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param out Pointer to oid to be filled in
  /// @param repo The repository in which to look up the reference
  /// @param name The long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)
  /// @return 0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.
  int reference_name_to_id(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _reference_name_to_id(
      out,
      repo,
      name,
    );
  }

  late final _reference_name_to_id_ptr =
      _lookup<ffi.NativeFunction<_c_reference_name_to_id>>(
          'git_reference_name_to_id');
  late final _dart_reference_name_to_id _reference_name_to_id =
      _reference_name_to_id_ptr.asFunction<_dart_reference_name_to_id>();

  /// Lookup a reference by DWIMing its short name
  ///
  /// Apply the git precendence rules to the given shorthand to determine
  /// which reference the user is referring to.
  ///
  /// @param out pointer in which to store the reference
  /// @param repo the repository in which to look
  /// @param shorthand the short name for the reference
  /// @return 0 or an error code
  int reference_dwim(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> shorthand,
  ) {
    return _reference_dwim(
      out,
      repo,
      shorthand,
    );
  }

  late final _reference_dwim_ptr =
      _lookup<ffi.NativeFunction<_c_reference_dwim>>('git_reference_dwim');
  late final _dart_reference_dwim _reference_dwim =
      _reference_dwim_ptr.asFunction<_dart_reference_dwim>();

  /// Get the OID pointed to by a direct reference.
  ///
  /// Only available if the reference is direct (i.e. an object id reference,
  /// not a symbolic one).
  ///
  /// To find the OID of a symbolic ref, call `git_reference_resolve()` and
  /// then this function (or maybe use `git_reference_name_to_id()` to
  /// directly resolve a reference name all the way through to an OID).
  ///
  /// @param ref The reference
  /// @return a pointer to the oid if available, NULL otherwise
  ffi.Pointer<git_oid> reference_target(
    ffi.Pointer<git_reference> ref,
  ) {
    return _reference_target(
      ref,
    );
  }

  late final _reference_target_ptr =
      _lookup<ffi.NativeFunction<_c_reference_target>>('git_reference_target');
  late final _dart_reference_target _reference_target =
      _reference_target_ptr.asFunction<_dart_reference_target>();

  /// Get the full name of a reference.
  ///
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param ref The reference
  /// @return the full name for the ref
  ffi.Pointer<ffi.Int8> reference_name(
    ffi.Pointer<git_reference> ref,
  ) {
    return _reference_name(
      ref,
    );
  }

  late final _reference_name_ptr =
      _lookup<ffi.NativeFunction<_c_reference_name>>('git_reference_name');
  late final _dart_reference_name _reference_name =
      _reference_name_ptr.asFunction<_dart_reference_name>();

  /// Resolve a symbolic reference to a direct reference.
  ///
  /// This method iteratively peels a symbolic reference until it resolves to
  /// a direct reference to an OID.
  ///
  /// The peeled reference is returned in the `resolved_ref` argument, and
  /// must be freed manually once it's no longer needed.
  ///
  /// If a direct reference is passed as an argument, a copy of that
  /// reference is returned. This copy must be manually freed too.
  ///
  /// @param out Pointer to the peeled reference
  /// @param ref The reference
  /// @return 0 or an error code
  int reference_resolve(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> ref,
  ) {
    return _reference_resolve(
      out,
      ref,
    );
  }

  late final _reference_resolve_ptr =
      _lookup<ffi.NativeFunction<_c_reference_resolve>>(
          'git_reference_resolve');
  late final _dart_reference_resolve _reference_resolve =
      _reference_resolve_ptr.asFunction<_dart_reference_resolve>();

  /// Conditionally create a new reference with the same name as the given reference but a
  /// different OID target. The reference must be a direct reference, otherwise
  /// this will fail.
  ///
  /// The new reference will be written to disk, overwriting the given reference.
  ///
  /// @param out Pointer to the newly created reference
  /// @param ref The reference
  /// @param id The new target OID for the reference
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EMODIFIED if the value of the reference
  /// has changed since it was read, or an error code
  int reference_set_target(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> ref,
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Int8> log_message,
  ) {
    return _reference_set_target(
      out,
      ref,
      id,
      log_message,
    );
  }

  late final _reference_set_target_ptr =
      _lookup<ffi.NativeFunction<_c_reference_set_target>>(
          'git_reference_set_target');
  late final _dart_reference_set_target _reference_set_target =
      _reference_set_target_ptr.asFunction<_dart_reference_set_target>();

  /// Free the given reference.
  ///
  /// @param ref git_reference
  void reference_free(
    ffi.Pointer<git_reference> ref,
  ) {
    return _reference_free(
      ref,
    );
  }

  late final _reference_free_ptr =
      _lookup<ffi.NativeFunction<_c_reference_free>>('git_reference_free');
  late final _dart_reference_free _reference_free =
      _reference_free_ptr.asFunction<_dart_reference_free>();

  /// Get the branch name
  ///
  /// Given a reference object, this will check that it really is a branch (ie.
  /// it lives under "refs/heads/" or "refs/remotes/"), and return the branch part
  /// of it.
  ///
  /// @param out Pointer to the abbreviated reference name.
  /// Owned by ref, do not free.
  ///
  /// @param ref A reference object, ideally pointing to a branch
  ///
  /// @return 0 on success; GIT_EINVALID if the reference isn't either a local or
  /// remote branch, otherwise an error code.
  int branch_name(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> out,
    ffi.Pointer<git_reference> ref,
  ) {
    return _branch_name(
      out,
      ref,
    );
  }

  late final _branch_name_ptr =
      _lookup<ffi.NativeFunction<_c_branch_name>>('git_branch_name');
  late final _dart_branch_name _branch_name =
      _branch_name_ptr.asFunction<_dart_branch_name>();

  /// Get the upstream of a branch
  ///
  /// Given a reference, this will return a new reference object corresponding
  /// to its remote tracking branch. The reference must be a local branch.
  ///
  /// @see git_branch_upstream_name for details on the resolution.
  ///
  /// @param out Pointer where to store the retrieved reference.
  /// @param branch Current underlying reference of the branch.
  ///
  /// @return 0 on success; GIT_ENOTFOUND when no remote tracking
  /// reference exists, otherwise an error code.
  int branch_upstream(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> branch,
  ) {
    return _branch_upstream(
      out,
      branch,
    );
  }

  late final _branch_upstream_ptr =
      _lookup<ffi.NativeFunction<_c_branch_upstream>>('git_branch_upstream');
  late final _dart_branch_upstream _branch_upstream =
      _branch_upstream_ptr.asFunction<_dart_branch_upstream>();

  /// Initialize git_checkout_options structure
  ///
  /// Initializes a `git_checkout_options` with default values. Equivalent to creating
  /// an instance with GIT_CHECKOUT_OPTIONS_INIT.
  ///
  /// @param opts The `git_checkout_options` struct to initialize.
  /// @param version The struct version; pass `GIT_CHECKOUT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int checkout_options_init(
    ffi.Pointer<git_checkout_options> opts,
    int version,
  ) {
    return _checkout_options_init(
      opts,
      version,
    );
  }

  late final _checkout_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_checkout_options_init>>(
          'git_checkout_options_init');
  late final _dart_checkout_options_init _checkout_options_init =
      _checkout_options_init_ptr.asFunction<_dart_checkout_options_init>();

  /// Updates files in the index and the working tree to match the content of
  /// the commit pointed at by HEAD.
  ///
  /// Note that this is _not_ the correct mechanism used to switch branches;
  /// do not change your `HEAD` and then call this method, that would leave
  /// you with checkout conflicts since your working directory would then
  /// appear to be dirty.  Instead, checkout the target of the branch and
  /// then update `HEAD` using `git_repository_set_head` to point to the
  /// branch you checked out.
  ///
  /// @param repo repository to check out (must be non-bare)
  /// @param opts specifies checkout options (may be NULL)
  /// @return 0 on success, GIT_EUNBORNBRANCH if HEAD points to a non
  /// existing branch, non-zero value returned by `notify_cb`, or
  /// other error code < 0 (use git_error_last for error details)
  int checkout_head(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_checkout_options> opts,
  ) {
    return _checkout_head(
      repo,
      opts,
    );
  }

  late final _checkout_head_ptr =
      _lookup<ffi.NativeFunction<_c_checkout_head>>('git_checkout_head');
  late final _dart_checkout_head _checkout_head =
      _checkout_head_ptr.asFunction<_dart_checkout_head>();

  /// Updates files in the index and working tree to match the content of the
  /// tree pointed at by the treeish.
  ///
  /// @param repo repository to check out (must be non-bare)
  /// @param treeish a commit, tag or tree which content will be used to update
  /// the working directory (or NULL to use HEAD)
  /// @param opts specifies checkout options (may be NULL)
  /// @return 0 on success, non-zero return value from `notify_cb`, or error
  /// code < 0 (use git_error_last for error details)
  int checkout_tree(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_object> treeish,
    ffi.Pointer<git_checkout_options> opts,
  ) {
    return _checkout_tree(
      repo,
      treeish,
      opts,
    );
  }

  late final _checkout_tree_ptr =
      _lookup<ffi.NativeFunction<_c_checkout_tree>>('git_checkout_tree');
  late final _dart_checkout_tree _checkout_tree =
      _checkout_tree_ptr.asFunction<_dart_checkout_tree>();

  /// Free an existing index object.
  ///
  /// @param index an existing index object
  void index_free(
    ffi.Pointer<git_index> index,
  ) {
    return _index_free(
      index,
    );
  }

  late final _index_free_ptr =
      _lookup<ffi.NativeFunction<_c_index_free>>('git_index_free');
  late final _dart_index_free _index_free =
      _index_free_ptr.asFunction<_dart_index_free>();

  /// Write an existing index object from memory back to disk
  /// using an atomic file lock.
  ///
  /// @param index an existing index object
  /// @return 0 or an error code
  int index_write(
    ffi.Pointer<git_index> index,
  ) {
    return _index_write(
      index,
    );
  }

  late final _index_write_ptr =
      _lookup<ffi.NativeFunction<_c_index_write>>('git_index_write');
  late final _dart_index_write _index_write =
      _index_write_ptr.asFunction<_dart_index_write>();

  /// Write the index as a tree
  ///
  /// This method will scan the index and write a representation
  /// of its current state back to disk; it recursively creates
  /// tree objects for each of the subtrees stored in the index,
  /// but only returns the OID of the root tree. This is the OID
  /// that can be used e.g. to create a commit.
  ///
  /// The index instance cannot be bare, and needs to be associated
  /// to an existing repository.
  ///
  /// The index must not contain any file in conflict.
  ///
  /// @param out Pointer where to store the OID of the written tree
  /// @param index Index to write
  /// @return 0 on success, GIT_EUNMERGED when the index is not clean
  /// or an error code
  int index_write_tree(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_index> index,
  ) {
    return _index_write_tree(
      out,
      index,
    );
  }

  late final _index_write_tree_ptr =
      _lookup<ffi.NativeFunction<_c_index_write_tree>>('git_index_write_tree');
  late final _dart_index_write_tree _index_write_tree =
      _index_write_tree_ptr.asFunction<_dart_index_write_tree>();

  /// Add or update an index entry from a file on disk
  ///
  /// The file `path` must be relative to the repository's
  /// working folder and must be readable.
  ///
  /// This method will fail in bare index instances.
  ///
  /// This forces the file to be added to the index, not looking
  /// at gitignore rules.  Those rules can be evaluated through
  /// the git_status APIs (in status.h) before calling this.
  ///
  /// If this file currently is the result of a merge conflict, this
  /// file will no longer be marked as conflicting.  The data about
  /// the conflict will be moved to the "resolve undo" (REUC) section.
  ///
  /// @param index an existing index object
  /// @param path filename to add
  /// @return 0 or an error code
  int index_add_bypath(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _index_add_bypath(
      index,
      path,
    );
  }

  late final _index_add_bypath_ptr =
      _lookup<ffi.NativeFunction<_c_index_add_bypath>>('git_index_add_bypath');
  late final _dart_index_add_bypath _index_add_bypath =
      _index_add_bypath_ptr.asFunction<_dart_index_add_bypath>();

  /// Remove an index entry corresponding to a file on disk
  ///
  /// The file `path` must be relative to the repository's
  /// working folder.  It may exist.
  ///
  /// If this file currently is the result of a merge conflict, this
  /// file will no longer be marked as conflicting.  The data about
  /// the conflict will be moved to the "resolve undo" (REUC) section.
  ///
  /// @param index an existing index object
  /// @param path filename to remove
  /// @return 0 or an error code
  int index_remove_bypath(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _index_remove_bypath(
      index,
      path,
    );
  }

  late final _index_remove_bypath_ptr =
      _lookup<ffi.NativeFunction<_c_index_remove_bypath>>(
          'git_index_remove_bypath');
  late final _dart_index_remove_bypath _index_remove_bypath =
      _index_remove_bypath_ptr.asFunction<_dart_index_remove_bypath>();

  /// Initialize git_merge_options structure
  ///
  /// Initializes a `git_merge_options` with default values. Equivalent to
  /// creating an instance with `GIT_MERGE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_merge_options` struct to initialize.
  /// @param version The struct version; pass `GIT_MERGE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int merge_options_init(
    ffi.Pointer<git_merge_options> opts,
    int version,
  ) {
    return _merge_options_init(
      opts,
      version,
    );
  }

  late final _merge_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_merge_options_init>>(
          'git_merge_options_init');
  late final _dart_merge_options_init _merge_options_init =
      _merge_options_init_ptr.asFunction<_dart_merge_options_init>();

  /// Analyzes the given branch(es) and determines the opportunities for
  /// merging them into the HEAD of the repository.
  ///
  /// @param analysis_out analysis enumeration that the result is written into
  /// @param repo the repository to merge
  /// @param their_heads the heads to merge into
  /// @param their_heads_len the number of heads to merge
  /// @return 0 on success or error code
  int merge_analysis(
    ffi.Pointer<ffi.Int32> analysis_out,
    ffi.Pointer<ffi.Int32> preference_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
    int their_heads_len,
  ) {
    return _merge_analysis(
      analysis_out,
      preference_out,
      repo,
      their_heads,
      their_heads_len,
    );
  }

  late final _merge_analysis_ptr =
      _lookup<ffi.NativeFunction<_c_merge_analysis>>('git_merge_analysis');
  late final _dart_merge_analysis _merge_analysis =
      _merge_analysis_ptr.asFunction<_dart_merge_analysis>();

  /// Merges the given commit(s) into HEAD, writing the results into the working
  /// directory.  Any changes are staged for commit and any conflicts are written
  /// to the index.  Callers should inspect the repository's index after this
  /// completes, resolve any conflicts and prepare a commit.
  ///
  /// For compatibility with git, the repository is put into a merging
  /// state. Once the commit is done (or if the uses wishes to abort),
  /// you should clear this state by calling
  /// `git_repository_state_cleanup()`.
  ///
  /// @param repo the repository to merge
  /// @param their_heads the heads to merge into
  /// @param their_heads_len the number of heads to merge
  /// @param merge_opts merge options
  /// @param checkout_opts checkout options
  /// @return 0 on success or error code
  int merge(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
    int their_heads_len,
    ffi.Pointer<git_merge_options> merge_opts,
    ffi.Pointer<git_checkout_options> checkout_opts,
  ) {
    return _merge(
      repo,
      their_heads,
      their_heads_len,
      merge_opts,
      checkout_opts,
    );
  }

  late final _merge_ptr = _lookup<ffi.NativeFunction<_c_merge>>('git_merge');
  late final _dart_merge _merge = _merge_ptr.asFunction<_dart_merge>();

  /// Create a new plain-text username and password credential object.
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param out The newly created credential object.
  /// @param username The username of the credential.
  /// @param password The password of the credential.
  /// @return 0 for success or an error code for failure
  int credential_userpass_plaintext_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> username,
    ffi.Pointer<ffi.Int8> password,
  ) {
    return _credential_userpass_plaintext_new(
      out,
      username,
      password,
    );
  }

  late final _credential_userpass_plaintext_new_ptr =
      _lookup<ffi.NativeFunction<_c_credential_userpass_plaintext_new>>(
          'git_credential_userpass_plaintext_new');
  late final _dart_credential_userpass_plaintext_new
      _credential_userpass_plaintext_new =
      _credential_userpass_plaintext_new_ptr
          .asFunction<_dart_credential_userpass_plaintext_new>();

  /// Add a remote with the default fetch refspec to the repository's configuration.
  ///
  /// @param out the resulting remote
  /// @param repo the repository in which to create the remote
  /// @param name the remote's name
  /// @param url the remote's url
  /// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int remote_create(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> url,
  ) {
    return _remote_create(
      out,
      repo,
      name,
      url,
    );
  }

  late final _remote_create_ptr =
      _lookup<ffi.NativeFunction<_c_remote_create>>('git_remote_create');
  late final _dart_remote_create _remote_create =
      _remote_create_ptr.asFunction<_dart_remote_create>();

  /// Get the information for a particular remote
  ///
  /// The name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// @param out pointer to the new remote object
  /// @param repo the associated repository
  /// @param name the remote's name
  /// @return 0, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code
  int remote_lookup(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _remote_lookup(
      out,
      repo,
      name,
    );
  }

  late final _remote_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_remote_lookup>>('git_remote_lookup');
  late final _dart_remote_lookup _remote_lookup =
      _remote_lookup_ptr.asFunction<_dart_remote_lookup>();

  /// Free the memory associated with a remote
  ///
  /// This also disconnects from the remote, if the connection
  /// has not been closed yet (using git_remote_disconnect).
  ///
  /// @param remote the remote to free
  void remote_free(
    ffi.Pointer<git_remote> remote,
  ) {
    return _remote_free(
      remote,
    );
  }

  late final _remote_free_ptr =
      _lookup<ffi.NativeFunction<_c_remote_free>>('git_remote_free');
  late final _dart_remote_free _remote_free =
      _remote_free_ptr.asFunction<_dart_remote_free>();

  /// Get a list of the configured remotes for a repo
  ///
  /// The string array must be freed by the user.
  ///
  /// @param out a string array which receives the names of the remotes
  /// @param repo the repository to query
  /// @return 0 or an error code
  int remote_list(
    ffi.Pointer<git_strarray> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _remote_list(
      out,
      repo,
    );
  }

  late final _remote_list_ptr =
      _lookup<ffi.NativeFunction<_c_remote_list>>('git_remote_list');
  late final _dart_remote_list _remote_list =
      _remote_list_ptr.asFunction<_dart_remote_list>();

  /// Initialize git_fetch_options structure
  ///
  /// Initializes a `git_fetch_options` with default values. Equivalent to
  /// creating an instance with `GIT_FETCH_OPTIONS_INIT`.
  ///
  /// @param opts The `git_fetch_options` struct to initialize.
  /// @param version The struct version; pass `GIT_FETCH_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int fetch_options_init(
    ffi.Pointer<git_fetch_options> opts,
    int version,
  ) {
    return _fetch_options_init(
      opts,
      version,
    );
  }

  late final _fetch_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_fetch_options_init>>(
          'git_fetch_options_init');
  late final _dart_fetch_options_init _fetch_options_init =
      _fetch_options_init_ptr.asFunction<_dart_fetch_options_init>();

  /// Initialize git_push_options structure
  ///
  /// Initializes a `git_push_options` with default values. Equivalent to
  /// creating an instance with `GIT_PUSH_OPTIONS_INIT`.
  ///
  /// @param opts The `git_push_options` struct to initialize.
  /// @param version The struct version; pass `GIT_PUSH_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int push_options_init(
    ffi.Pointer<git_push_options> opts,
    int version,
  ) {
    return _push_options_init(
      opts,
      version,
    );
  }

  late final _push_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_push_options_init>>(
          'git_push_options_init');
  late final _dart_push_options_init _push_options_init =
      _push_options_init_ptr.asFunction<_dart_push_options_init>();

  /// Download new data and update tips
  ///
  /// Convenience function to connect to a remote, download the data,
  /// disconnect and update the remote-tracking branches.
  ///
  /// @param remote the remote to fetch from
  /// @param refspecs the refspecs to use for this fetch. Pass NULL or an
  /// empty array to use the base refspecs.
  /// @param opts options to use for this fetch
  /// @param reflog_message The message to insert into the reflogs. If NULL, the
  /// default is "fetch"
  /// @return 0 or an error code
  int remote_fetch(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_fetch_options> opts,
    ffi.Pointer<ffi.Int8> reflog_message,
  ) {
    return _remote_fetch(
      remote,
      refspecs,
      opts,
      reflog_message,
    );
  }

  late final _remote_fetch_ptr =
      _lookup<ffi.NativeFunction<_c_remote_fetch>>('git_remote_fetch');
  late final _dart_remote_fetch _remote_fetch =
      _remote_fetch_ptr.asFunction<_dart_remote_fetch>();

  /// Perform a push
  ///
  /// Peform all the steps from a push.
  ///
  /// @param remote the remote to push to
  /// @param refspecs the refspecs to use for pushing. If NULL or an empty
  /// array, the configured refspecs will be used
  /// @param opts options to use for this push
  int remote_push(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_push_options> opts,
  ) {
    return _remote_push(
      remote,
      refspecs,
      opts,
    );
  }

  late final _remote_push_ptr =
      _lookup<ffi.NativeFunction<_c_remote_push>>('git_remote_push');
  late final _dart_remote_push _remote_push =
      _remote_push_ptr.asFunction<_dart_remote_push>();

  /// Delete an existing persisted remote.
  ///
  /// All remote-tracking branches and configuration settings
  /// for the remote will be removed.
  ///
  /// @param repo the repository in which to act
  /// @param name the name of the remote to delete
  /// @return 0 on success, or an error code.
  int remote_delete(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _remote_delete(
      repo,
      name,
    );
  }

  late final _remote_delete_ptr =
      _lookup<ffi.NativeFunction<_c_remote_delete>>('git_remote_delete');
  late final _dart_remote_delete _remote_delete =
      _remote_delete_ptr.asFunction<_dart_remote_delete>();

  /// Initialize git_clone_options structure
  ///
  /// Initializes a `git_clone_options` with default values. Equivalent to creating
  /// an instance with GIT_CLONE_OPTIONS_INIT.
  ///
  /// @param opts The `git_clone_options` struct to initialize.
  /// @param version The struct version; pass `GIT_CLONE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int clone_options_init(
    ffi.Pointer<git_clone_options> opts,
    int version,
  ) {
    return _clone_options_init(
      opts,
      version,
    );
  }

  late final _clone_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_clone_options_init>>(
          'git_clone_options_init');
  late final _dart_clone_options_init _clone_options_init =
      _clone_options_init_ptr.asFunction<_dart_clone_options_init>();

  /// Clone a remote repository.
  ///
  /// By default this creates its repository and initial remote to match
  /// git's defaults. You can use the options in the callback to
  /// customize how these are created.
  ///
  /// @param out pointer that will receive the resulting repository object
  /// @param url the remote repository to clone
  /// @param local_path local directory to clone to
  /// @param options configuration options for the clone.  If NULL, the
  /// function works as though GIT_OPTIONS_INIT were passed.
  /// @return 0 on success, any non-zero return value from a callback
  /// function, or a negative value to indicate an error (use
  /// `git_error_last` for a detailed error message)
  int clone(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> url,
    ffi.Pointer<ffi.Int8> local_path,
    ffi.Pointer<git_clone_options> options,
  ) {
    return _clone(
      out,
      url,
      local_path,
      options,
    );
  }

  late final _clone_ptr = _lookup<ffi.NativeFunction<_c_clone>>('git_clone');
  late final _dart_clone _clone = _clone_ptr.asFunction<_dart_clone>();

  /// Lookup a commit object from a repository.
  ///
  /// The returned object should be released with `git_commit_free` when no
  /// longer needed.
  ///
  /// @param commit pointer to the looked up commit
  /// @param repo the repo to use when locating the commit.
  /// @param id identity of the commit to locate. If the object is
  /// an annotated tag it will be peeled back to the commit.
  /// @return 0 or an error code
  int commit_lookup(
    ffi.Pointer<ffi.Pointer<git_commit>> commit,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _commit_lookup(
      commit,
      repo,
      id,
    );
  }

  late final _commit_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_commit_lookup>>('git_commit_lookup');
  late final _dart_commit_lookup _commit_lookup =
      _commit_lookup_ptr.asFunction<_dart_commit_lookup>();

  /// Close an open commit
  ///
  /// This is a wrapper around git_object_free()
  ///
  /// IMPORTANT:
  /// It *is* necessary to call this method when you stop
  /// using a commit. Failure to do so will cause a memory leak.
  ///
  /// @param commit the commit to close
  void commit_free(
    ffi.Pointer<git_commit> commit,
  ) {
    return _commit_free(
      commit,
    );
  }

  late final _commit_free_ptr =
      _lookup<ffi.NativeFunction<_c_commit_free>>('git_commit_free');
  late final _dart_commit_free _commit_free =
      _commit_free_ptr.asFunction<_dart_commit_free>();

  /// Create new commit in the repository from a list of `git_object` pointers
  ///
  /// The message will **not** be cleaned up automatically. You can do that
  /// with the `git_message_prettify()` function.
  ///
  /// @param id Pointer in which to store the OID of the newly created commit
  ///
  /// @param repo Repository where to store the commit
  ///
  /// @param update_ref If not NULL, name of the reference that
  /// will be updated to point to this commit. If the reference
  /// is not direct, it will be resolved to a direct reference.
  /// Use "HEAD" to update the HEAD of the current branch and
  /// make it point to this commit. If the reference doesn't
  /// exist yet, it will be created. If it does exist, the first
  /// parent must be the tip of this branch.
  ///
  /// @param author Signature with author and author time of commit
  ///
  /// @param committer Signature with committer and * commit time of commit
  ///
  /// @param message_encoding The encoding for the message in the
  /// commit, represented with a standard encoding name.
  /// E.g. "UTF-8". If NULL, no encoding header is written and
  /// UTF-8 is assumed.
  ///
  /// @param message Full message for this commit
  ///
  /// @param tree An instance of a `git_tree` object that will
  /// be used as the tree for the commit. This tree object must
  /// also be owned by the given `repo`.
  ///
  /// @param parent_count Number of parents for this commit
  ///
  /// @param parents Array of `parent_count` pointers to `git_commit`
  /// objects that will be used as the parents for this commit. This
  /// array may be NULL if `parent_count` is 0 (root commit). All the
  /// given commits must be owned by the `repo`.
  ///
  /// @return 0 or an error code
  /// The created commit will be written to the Object Database and
  /// the given reference will be updated to point to it
  int commit_create(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> update_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Int8> message_encoding,
    ffi.Pointer<ffi.Int8> message,
    ffi.Pointer<git_tree> tree,
    int parent_count,
    ffi.Pointer<ffi.Pointer<git_commit>> parents,
  ) {
    return _commit_create(
      id,
      repo,
      update_ref,
      author,
      committer,
      message_encoding,
      message,
      tree,
      parent_count,
      parents,
    );
  }

  late final _commit_create_ptr =
      _lookup<ffi.NativeFunction<_c_commit_create>>('git_commit_create');
  late final _dart_commit_create _commit_create =
      _commit_create_ptr.asFunction<_dart_commit_create>();

  /// Return the last `git_error` object that was generated for the
  /// current thread.
  ///
  /// The default behaviour of this function is to return NULL if no previous error has occurred.
  /// However, libgit2's error strings are not cleared aggressively, so a prior
  /// (unrelated) error may be returned. This can be avoided by only calling
  /// this function if the prior call to a libgit2 API returned an error.
  ///
  /// @return A git_error object.
  ffi.Pointer<git_error> error_last() {
    return _error_last();
  }

  late final _error_last_ptr =
      _lookup<ffi.NativeFunction<_c_error_last>>('git_error_last');
  late final _dart_error_last _error_last =
      _error_last_ptr.asFunction<_dart_error_last>();

  /// Set the error message string for this thread.
  ///
  /// This function is public so that custom ODB backends and the like can
  /// relay an error message through libgit2.  Most regular users of libgit2
  /// will never need to call this function -- actually, calling it in most
  /// circumstances (for example, calling from within a callback function)
  /// will just end up having the value overwritten by libgit2 internals.
  ///
  /// This error message is stored in thread-local storage and only applies
  /// to the particular thread that this libgit2 call is made from.
  ///
  /// @param error_class One of the `git_error_t` enum above describing the
  /// general subsystem that is responsible for the error.
  /// @param string The formatted error message to keep
  /// @return 0 on success or -1 on failure
  int error_set_str(
    int error_class,
    ffi.Pointer<ffi.Int8> string,
  ) {
    return _error_set_str(
      error_class,
      string,
    );
  }

  late final _error_set_str_ptr =
      _lookup<ffi.NativeFunction<_c_error_set_str>>('git_error_set_str');
  late final _dart_error_set_str _error_set_str =
      _error_set_str_ptr.asFunction<_dart_error_set_str>();

  /// Initialize git_status_options structure
  ///
  /// Initializes a `git_status_options` with default values. Equivalent to
  /// creating an instance with `GIT_STATUS_OPTIONS_INIT`.
  ///
  /// @param opts The `git_status_options` struct to initialize.
  /// @param version The struct version; pass `GIT_STATUS_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int status_options_init(
    ffi.Pointer<git_status_options> opts,
    int version,
  ) {
    return _status_options_init(
      opts,
      version,
    );
  }

  late final _status_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_status_options_init>>(
          'git_status_options_init');
  late final _dart_status_options_init _status_options_init =
      _status_options_init_ptr.asFunction<_dart_status_options_init>();

  /// Gather file status information and populate the `git_status_list`.
  ///
  /// Note that if a `pathspec` is given in the `git_status_options` to filter
  /// the status, then the results from rename detection (if you enable it) may
  /// not be accurate.  To do rename detection properly, this must be called
  /// with no `pathspec` so that all files can be considered.
  ///
  /// @param out Pointer to store the status results in
  /// @param repo Repository object
  /// @param opts Status options structure
  /// @return 0 on success or error code
  int status_list_new(
    ffi.Pointer<ffi.Pointer<git_status_list>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_status_options> opts,
  ) {
    return _status_list_new(
      out,
      repo,
      opts,
    );
  }

  late final _status_list_new_ptr =
      _lookup<ffi.NativeFunction<_c_status_list_new>>('git_status_list_new');
  late final _dart_status_list_new _status_list_new =
      _status_list_new_ptr.asFunction<_dart_status_list_new>();

  /// Gets the count of status entries in this list.
  ///
  /// If there are no changes in status (at least according the options given
  /// when the status list was created), this can return 0.
  ///
  /// @param statuslist Existing status list object
  /// @return the number of status entries
  int status_list_entrycount(
    ffi.Pointer<git_status_list> statuslist,
  ) {
    return _status_list_entrycount(
      statuslist,
    );
  }

  late final _status_list_entrycount_ptr =
      _lookup<ffi.NativeFunction<_c_status_list_entrycount>>(
          'git_status_list_entrycount');
  late final _dart_status_list_entrycount _status_list_entrycount =
      _status_list_entrycount_ptr.asFunction<_dart_status_list_entrycount>();

  /// Get a pointer to one of the entries in the status list.
  ///
  /// The entry is not modifiable and should not be freed.
  ///
  /// @param statuslist Existing status list object
  /// @param idx Position of the entry
  /// @return Pointer to the entry; NULL if out of bounds
  ffi.Pointer<git_status_entry> status_byindex(
    ffi.Pointer<git_status_list> statuslist,
    int idx,
  ) {
    return _status_byindex(
      statuslist,
      idx,
    );
  }

  late final _status_byindex_ptr =
      _lookup<ffi.NativeFunction<_c_status_byindex>>('git_status_byindex');
  late final _dart_status_byindex _status_byindex =
      _status_byindex_ptr.asFunction<_dart_status_byindex>();

  /// Free an existing status list
  ///
  /// @param statuslist Existing status list object
  void status_list_free(
    ffi.Pointer<git_status_list> statuslist,
  ) {
    return _status_list_free(
      statuslist,
    );
  }

  late final _status_list_free_ptr =
      _lookup<ffi.NativeFunction<_c_status_list_free>>('git_status_list_free');
  late final _dart_status_list_free _status_list_free =
      _status_list_free_ptr.asFunction<_dart_status_list_free>();

  /// Init the global state
  ///
  /// This function must be called before any other libgit2 function in
  /// order to set up global state and threading.
  ///
  /// This function may be called multiple times - it will return the number
  /// of times the initialization has been called (including this one) that have
  /// not subsequently been shutdown.
  ///
  /// @return the number of initializations of the library, or an error code.
  int libgit2_init() {
    return _libgit2_init();
  }

  late final _libgit2_init_ptr =
      _lookup<ffi.NativeFunction<_c_libgit2_init>>('git_libgit2_init');
  late final _dart_libgit2_init _libgit2_init =
      _libgit2_init_ptr.asFunction<_dart_libgit2_init>();

  /// Shutdown the global state
  ///
  /// Clean up the global state and threading context after calling it as
  /// many times as `git_libgit2_init()` was called - it will return the
  /// number of remainining initializations that have not been shutdown
  /// (after this one).
  ///
  /// @return the number of remaining initializations of the library, or an
  /// error code.
  int libgit2_shutdown() {
    return _libgit2_shutdown();
  }

  late final _libgit2_shutdown_ptr =
      _lookup<ffi.NativeFunction<_c_libgit2_shutdown>>('git_libgit2_shutdown');
  late final _dart_libgit2_shutdown _libgit2_shutdown =
      _libgit2_shutdown_ptr.asFunction<_dart_libgit2_shutdown>();

  /// Count the number of unique commits between two commit objects
  ///
  /// There is no need for branches containing the commits to have any
  /// upstream relationship, but it helps to think of one as a branch and
  /// the other as its upstream, the `ahead` and `behind` values will be
  /// what git would report for the branches.
  ///
  /// @param ahead number of unique from commits in `upstream`
  /// @param behind number of unique from commits in `local`
  /// @param repo the repository where the commits exist
  /// @param local the commit for local
  /// @param upstream the commit for upstream
  int graph_ahead_behind(
    ffi.Pointer<ffi.IntPtr> ahead,
    ffi.Pointer<ffi.IntPtr> behind,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> local,
    ffi.Pointer<git_oid> upstream,
  ) {
    return _graph_ahead_behind(
      ahead,
      behind,
      repo,
      local,
      upstream,
    );
  }

  late final _graph_ahead_behind_ptr =
      _lookup<ffi.NativeFunction<_c_graph_ahead_behind>>(
          'git_graph_ahead_behind');
  late final _dart_graph_ahead_behind _graph_ahead_behind =
      _graph_ahead_behind_ptr.asFunction<_dart_graph_ahead_behind>();

  /// Create a new action signature with a timestamp of 'now'.
  ///
  /// Call `git_signature_free()` to free the data.
  ///
  /// @param out new signature, in case of error NULL
  /// @param name name of the person
  /// @param email email of the person
  /// @return 0 or an error code
  int signature_now(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> email,
  ) {
    return _signature_now(
      out,
      name,
      email,
    );
  }

  late final _signature_now_ptr =
      _lookup<ffi.NativeFunction<_c_signature_now>>('git_signature_now');
  late final _dart_signature_now _signature_now =
      _signature_now_ptr.asFunction<_dart_signature_now>();

  /// Free an existing signature.
  ///
  /// Because the signature is not an opaque structure, it is legal to free it
  /// manually, but be sure to free the "name" and "email" strings in addition
  /// to the structure itself.
  ///
  /// @param sig signature to free
  void signature_free(
    ffi.Pointer<git_signature> sig,
  ) {
    return _signature_free(
      sig,
    );
  }

  late final _signature_free_ptr =
      _lookup<ffi.NativeFunction<_c_signature_free>>('git_signature_free');
  late final _dart_signature_free _signature_free =
      _signature_free_ptr.asFunction<_dart_signature_free>();
}

/// A data buffer for exporting data from libgit2
///
/// Sometimes libgit2 wants to return an allocated data buffer to the
/// caller and have the caller take responsibility for freeing that memory.
/// This can be awkward if the caller does not have easy access to the same
/// allocation functions that libgit2 is using.  In those cases, libgit2
/// will fill in a `git_buf` and the caller can use `git_buf_dispose()` to
/// release it when they are done.
///
/// A `git_buf` may also be used for the caller to pass in a reference to
/// a block of memory they hold.  In this case, libgit2 will not resize or
/// free the memory, but will read from it as needed.
///
/// Some APIs may occasionally do something slightly unusual with a buffer,
/// such as setting `ptr` to a value that was passed in by the user.  In
/// those cases, the behavior will be clearly documented by the API.
class git_buf extends ffi.Struct {
  /// The buffer contents.
  ///
  /// `ptr` points to the start of the allocated memory.  If it is NULL,
  /// then the `git_buf` is considered empty and libgit2 will feel free
  /// to overwrite it with new data.
  external ffi.Pointer<ffi.Int8> ptr;

  /// `asize` holds the known total amount of allocated memory if the `ptr`
  /// was allocated by libgit2.  It may be larger than `size`.  If `ptr`
  /// was not allocated by libgit2 and should not be resized and/or freed,
  /// then `asize` will be set to zero.
  @ffi.IntPtr()
  external int asize;

  /// `size` holds the size (in bytes) of the data that is actually used.
  @ffi.IntPtr()
  external int size;
}

/// Unique identity of any object (commit, tree, blob, tag).
class git_oid extends ffi.Struct {
  @ffi.Array.multi([20])
  external ffi.Array<ffi.Uint8> id;
}

/// Time in a signature
class git_time extends ffi.Struct {
  /// < time in seconds from epoch
  @ffi.Int64()
  external int time;

  /// < timezone offset, in minutes
  @ffi.Int32()
  external int offset;

  /// < indicator for questionable '-0000' offsets in signature
  @ffi.Int8()
  external int sign;
}

/// An action signature (e.g. for committers, taggers, etc)
class git_signature extends ffi.Struct {
  /// < full name of the author
  external ffi.Pointer<ffi.Int8> name;

  /// < email of the author
  external ffi.Pointer<ffi.Int8> email;

  /// < time when the action happened
  external git_time when;
}

/// The base structure for all credential types
class git_credential extends ffi.Struct {
  /// < A type of credential
  @ffi.Int32()
  external int credtype;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_3>> free;
}

/// Parent type for `git_cert_hostkey` and `git_cert_x509`.
class git_cert extends ffi.Struct {
  /// Type of certificate. A `GIT_CERT_` value.
  @ffi.Int32()
  external int cert_type;
}

/// This structure is used to provide callers information about the
/// progress of indexing a packfile, either directly or part of a
/// fetch or clone that downloads a packfile.
class git_indexer_progress extends ffi.Struct {
  /// number of objects in the packfile being indexed
  @ffi.Uint32()
  external int total_objects;

  /// received objects that have been hashed
  @ffi.Uint32()
  external int indexed_objects;

  /// received_objects: objects which have been downloaded
  @ffi.Uint32()
  external int received_objects;

  /// locally-available objects that have been injected in order
  /// to fix a thin pack
  @ffi.Uint32()
  external int local_objects;

  /// number of deltas in the packfile being indexed
  @ffi.Uint32()
  external int total_deltas;

  /// received deltas that have been indexed
  @ffi.Uint32()
  external int indexed_deltas;

  /// size of the packfile received up to now
  @ffi.IntPtr()
  external int received_bytes;
}

/// Represents an update which will be performed on the remote during push
class git_push_update extends ffi.Struct {
  /// The source name of the reference
  external ffi.Pointer<ffi.Int8> src_refname;

  /// The name of the reference to update on the server
  external ffi.Pointer<ffi.Int8> dst_refname;

  /// The current target of the reference
  external git_oid src;

  /// The new target for the reference
  external git_oid dst;
}

class git_transport extends ffi.Opaque {}

class git_remote extends ffi.Opaque {}

/// The callback settings structure
///
/// Set the callbacks to be called by the remote when informing the user
/// about the progress of the network operations.
class git_remote_callbacks extends ffi.Struct {
  /// < The version
  @ffi.Uint32()
  external int version;

  /// Textual progress from the remote. Text send over the
  /// progress side-band will be passed to this function (this is
  /// the 'counting objects' output).
  external ffi.Pointer<ffi.NativeFunction<git_transport_message_cb>>
      sideband_progress;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_1>> completion;

  /// This will be called if the remote host requires
  /// authentication in order to connect to it.
  ///
  /// Returning GIT_PASSTHROUGH will make libgit2 behave as
  /// though this field isn't set.
  external ffi.Pointer<ffi.NativeFunction<git_credential_acquire_cb>>
      credentials;

  /// If cert verification fails, this will be called to let the
  /// user make the final decision of whether to allow the
  /// connection to proceed. Returns 0 to allow the connection
  /// or a negative value to indicate an error.
  external ffi.Pointer<ffi.NativeFunction<git_transport_certificate_check_cb>>
      certificate_check;

  /// During the download of new data, this will be regularly
  /// called with the current count of progress done by the
  /// indexer.
  external ffi.Pointer<ffi.NativeFunction<git_indexer_progress_cb>>
      transfer_progress;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_2>> update_tips;

  /// Function to call with progress information during pack
  /// building. Be aware that this is called inline with pack
  /// building operations, so performance may be affected.
  external ffi.Pointer<ffi.NativeFunction<git_packbuilder_progress>>
      pack_progress;

  /// Function to call with progress information during the
  /// upload portion of a push. Be aware that this is called
  /// inline with pack building operations, so performance may be
  /// affected.
  external ffi.Pointer<ffi.NativeFunction<git_push_transfer_progress_cb>>
      push_transfer_progress;

  /// See documentation of git_push_update_reference_cb
  external ffi.Pointer<ffi.NativeFunction<git_push_update_reference_cb>>
      push_update_reference;

  /// Called once between the negotiation step and the upload. It
  /// provides information about what updates will be performed.
  external ffi.Pointer<ffi.NativeFunction<git_push_negotiation>>
      push_negotiation;

  /// Create the transport to use for this operation. Leave NULL
  /// to auto-detect.
  external ffi.Pointer<ffi.NativeFunction<git_transport_cb>> transport;

  /// This will be passed to each of the callbacks in this struct
  /// as the last parameter.
  external ffi.Pointer<ffi.Void> payload;

  /// Resolve URL before connecting to remote.
  /// The returned URL will be used to connect to the remote instead.
  external ffi.Pointer<ffi.NativeFunction<git_url_resolve_cb>> resolve_url;
}

class git_repository extends ffi.Opaque {}

/// Extended options structure for `git_repository_init_ext`.
///
/// This contains extra options for `git_repository_init_ext` that enable
/// additional initialization features.  The fields are:
///
/// * flags - Combination of GIT_REPOSITORY_INIT flags above.
/// * mode  - Set to one of the standard GIT_REPOSITORY_INIT_SHARED_...
/// constants above, or to a custom value that you would like.
/// * workdir_path - The path to the working dir or NULL for default (i.e.
/// repo_path parent on non-bare repos).  IF THIS IS RELATIVE PATH,
/// IT WILL BE EVALUATED RELATIVE TO THE REPO_PATH.  If this is not
/// the "natural" working directory, a .git gitlink file will be
/// created here linking to the repo_path.
/// * description - If set, this will be used to initialize the "description"
/// file in the repository, instead of using the template content.
/// * template_path - When GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE is set,
/// this contains the path to use for the template directory.  If
/// this is NULL, the config or default directory options will be
/// used instead.
/// * initial_head - The name of the head to point HEAD at.  If NULL, then
/// this will be treated as "master" and the HEAD ref will be set
/// to "refs/heads/master".  If this begins with "refs/" it will be
/// used verbatim; otherwise "refs/heads/" will be prefixed.
/// * origin_url - If this is non-NULL, then after the rest of the
/// repository initialization is completed, an "origin" remote
/// will be added pointing to this URL.
class git_repository_init_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  @ffi.Uint32()
  external int flags;

  @ffi.Uint32()
  external int mode;

  external ffi.Pointer<ffi.Int8> workdir_path;

  external ffi.Pointer<ffi.Int8> description;

  external ffi.Pointer<ffi.Int8> template_path;

  external ffi.Pointer<ffi.Int8> initial_head;

  external ffi.Pointer<ffi.Int8> origin_url;
}

class git_reference extends ffi.Opaque {}

class git_index extends ffi.Opaque {}

class git_annotated_commit extends ffi.Opaque {}

class git_tree extends ffi.Opaque {}

/// Array of strings
class git_strarray extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<ffi.Int8>> strings;

  @ffi.IntPtr()
  external int count;
}

/// Description of one side of a delta.
///
/// Although this is called a "file", it could represent a file, a symbolic
/// link, a submodule commit id, or even a tree (although that only if you
/// are tracking type changes or ignored/untracked directories).
///
/// The `id` is the `git_oid` of the item.  If the entry represents an
/// absent side of a diff (e.g. the `old_file` of a `GIT_DELTA_ADDED` delta),
/// then the oid will be zeroes.
///
/// `path` is the NUL-terminated path to the entry relative to the working
/// directory of the repository.
///
/// `size` is the size of the entry in bytes.
///
/// `flags` is a combination of the `git_diff_flag_t` types
///
/// `mode` is, roughly, the stat() `st_mode` value for the item.  This will
/// be restricted to one of the `git_filemode_t` values.
///
/// The `id_abbrev` represents the known length of the `id` field, when
/// converted to a hex string.  It is generally `GIT_OID_HEXSZ`, unless this
/// delta was created from reading a patch file, in which case it may be
/// abbreviated to something reasonable, like 7 characters.
class git_diff_file extends ffi.Struct {
  external git_oid id;

  external ffi.Pointer<ffi.Int8> path;

  @ffi.Uint64()
  external int size;

  @ffi.Uint32()
  external int flags;

  @ffi.Uint16()
  external int mode;

  @ffi.Uint16()
  external int id_abbrev;
}

/// Description of changes to one entry.
///
/// A `delta` is a file pair with an old and new revision.  The old version
/// may be absent if the file was just created and the new version may be
/// absent if the file was deleted.  A diff is mostly just a list of deltas.
///
/// When iterating over a diff, this will be passed to most callbacks and
/// you can use the contents to understand exactly what has changed.
///
/// The `old_file` represents the "from" side of the diff and the `new_file`
/// represents to "to" side of the diff.  What those means depend on the
/// function that was used to generate the diff and will be documented below.
/// You can also use the `GIT_DIFF_REVERSE` flag to flip it around.
///
/// Although the two sides of the delta are named "old_file" and "new_file",
/// they actually may correspond to entries that represent a file, a symbolic
/// link, a submodule commit id, or even a tree (if you are tracking type
/// changes or ignored/untracked directories).
///
/// Under some circumstances, in the name of efficiency, not all fields will
/// be filled in, but we generally try to fill in as much as possible.  One
/// example is that the "flags" field may not have either the `BINARY` or the
/// `NOT_BINARY` flag set to avoid examining file contents if you do not pass
/// in hunk and/or line callbacks to the diff foreach iteration function.  It
/// will just use the git attributes for those files.
///
/// The similarity score is zero unless you call `git_diff_find_similar()`
/// which does a similarity analysis of files in the diff.  Use that
/// function to do rename and copy detection, and to split heavily modified
/// files in add/delete pairs.  After that call, deltas with a status of
/// GIT_DELTA_RENAMED or GIT_DELTA_COPIED will have a similarity score
/// between 0 and 100 indicating how similar the old and new sides are.
///
/// If you ask `git_diff_find_similar` to find heavily modified files to
/// break, but to not *actually* break the records, then GIT_DELTA_MODIFIED
/// records may have a non-zero similarity score if the self-similarity is
/// below the split threshold.  To display this value like core Git, invert
/// the score (a la `printf("M%03d", 100 - delta->similarity)`).
class git_diff_delta extends ffi.Struct {
  @ffi.Int32()
  external int status;

  /// < git_diff_flag_t values
  @ffi.Uint32()
  external int flags;

  /// < for RENAMED and COPIED, value 0-100
  @ffi.Uint16()
  external int similarity;

  /// < number of files in this delta
  @ffi.Uint16()
  external int nfiles;

  external git_diff_file old_file;

  external git_diff_file new_file;
}

/// Checkout behavior flags
///
/// In libgit2, checkout is used to update the working directory and index
/// to match a target tree.  Unlike git checkout, it does not move the HEAD
/// commit for you - use `git_repository_set_head` or the like to do that.
///
/// Checkout looks at (up to) four things: the "target" tree you want to
/// check out, the "baseline" tree of what was checked out previously, the
/// working directory for actual files, and the index for staged changes.
///
/// You give checkout one of three strategies for update:
///
/// - `GIT_CHECKOUT_NONE` is a dry-run strategy that checks for conflicts,
/// etc., but doesn't make any actual changes.
///
/// - `GIT_CHECKOUT_FORCE` is at the opposite extreme, taking any action to
/// make the working directory match the target (including potentially
/// discarding modified files).
///
/// - `GIT_CHECKOUT_SAFE` is between these two options, it will only make
/// modifications that will not lose changes.
///
/// |  target == baseline   |  target != baseline  |
/// ---------------------|-----------------------|----------------------|
/// workdir == baseline |       no action       |  create, update, or  |
/// |                       |     delete file      |
/// ---------------------|-----------------------|----------------------|
/// workdir exists and  |       no action       |   conflict (notify   |
/// is != baseline    | notify dirty MODIFIED | and cancel checkout) |
/// ---------------------|-----------------------|----------------------|
/// workdir missing,   | notify dirty DELETED  |     create file      |
/// baseline present   |                       |                      |
/// ---------------------|-----------------------|----------------------|
///
/// To emulate `git checkout`, use `GIT_CHECKOUT_SAFE` with a checkout
/// notification callback (see below) that displays information about dirty
/// files.  The default behavior will cancel checkout on conflicts.
///
/// To emulate `git checkout-index`, use `GIT_CHECKOUT_SAFE` with a
/// notification callback that cancels the operation if a dirty-but-existing
/// file is found in the working directory.  This core git command isn't
/// quite "force" but is sensitive about some types of changes.
///
/// To emulate `git checkout -f`, use `GIT_CHECKOUT_FORCE`.
///
///
/// There are some additional flags to modify the behavior of checkout:
///
/// - GIT_CHECKOUT_ALLOW_CONFLICTS makes SAFE mode apply safe file updates
/// even if there are conflicts (instead of cancelling the checkout).
///
/// - GIT_CHECKOUT_REMOVE_UNTRACKED means remove untracked files (i.e. not
/// in target, baseline, or index, and not ignored) from the working dir.
///
/// - GIT_CHECKOUT_REMOVE_IGNORED means remove ignored files (that are also
/// untracked) from the working directory as well.
///
/// - GIT_CHECKOUT_UPDATE_ONLY means to only update the content of files that
/// already exist.  Files will not be created nor deleted.  This just skips
/// applying adds, deletes, and typechanges.
///
/// - GIT_CHECKOUT_DONT_UPDATE_INDEX prevents checkout from writing the
/// updated files' information to the index.
///
/// - Normally, checkout will reload the index and git attributes from disk
/// before any operations.  GIT_CHECKOUT_NO_REFRESH prevents this reload.
///
/// - Unmerged index entries are conflicts.  GIT_CHECKOUT_SKIP_UNMERGED skips
/// files with unmerged index entries instead.  GIT_CHECKOUT_USE_OURS and
/// GIT_CHECKOUT_USE_THEIRS to proceed with the checkout using either the
/// stage 2 ("ours") or stage 3 ("theirs") version of files in the index.
///
/// - GIT_CHECKOUT_DONT_OVERWRITE_IGNORED prevents ignored files from being
/// overwritten.  Normally, files that are ignored in the working directory
/// are not considered "precious" and may be overwritten if the checkout
/// target contains that file.
///
/// - GIT_CHECKOUT_DONT_REMOVE_EXISTING prevents checkout from removing
/// files or folders that fold to the same name on case insensitive
/// filesystems.  This can cause files to retain their existing names
/// and write through existing symbolic links.
abstract class git_checkout_strategy_t {
  /// < default is a dry run, no actual updates
  static const int GIT_CHECKOUT_NONE = 0;

  /// Allow safe updates that cannot overwrite uncommitted data.
  /// If the uncommitted changes don't conflict with the checked out files,
  /// the checkout will still proceed, leaving the changes intact.
  ///
  /// Mutually exclusive with GIT_CHECKOUT_FORCE.
  /// GIT_CHECKOUT_FORCE takes precedence over GIT_CHECKOUT_SAFE.
  static const int GIT_CHECKOUT_SAFE = 1;

  /// Allow all updates to force working directory to look like index.
  ///
  /// Mutually exclusive with GIT_CHECKOUT_SAFE.
  /// GIT_CHECKOUT_FORCE takes precedence over GIT_CHECKOUT_SAFE.
  static const int GIT_CHECKOUT_FORCE = 2;

  /// Allow checkout to recreate missing files
  static const int GIT_CHECKOUT_RECREATE_MISSING = 4;

  /// Allow checkout to make safe updates even if conflicts are found
  static const int GIT_CHECKOUT_ALLOW_CONFLICTS = 16;

  /// Remove untracked files not in index (that are not ignored)
  static const int GIT_CHECKOUT_REMOVE_UNTRACKED = 32;

  /// Remove ignored files not in index
  static const int GIT_CHECKOUT_REMOVE_IGNORED = 64;

  /// Only update existing files, don't create new ones
  static const int GIT_CHECKOUT_UPDATE_ONLY = 128;

  /// Normally checkout updates index entries as it goes; this stops that.
  /// Implies `GIT_CHECKOUT_DONT_WRITE_INDEX`.
  static const int GIT_CHECKOUT_DONT_UPDATE_INDEX = 256;

  /// Don't refresh index/config/etc before doing checkout
  static const int GIT_CHECKOUT_NO_REFRESH = 512;

  /// Allow checkout to skip unmerged files
  static const int GIT_CHECKOUT_SKIP_UNMERGED = 1024;

  /// For unmerged files, checkout stage 2 from index
  static const int GIT_CHECKOUT_USE_OURS = 2048;

  /// For unmerged files, checkout stage 3 from index
  static const int GIT_CHECKOUT_USE_THEIRS = 4096;

  /// Treat pathspec as simple list of exact match file paths
  static const int GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH = 8192;

  /// Ignore directories in use, they will be left empty
  static const int GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES = 262144;

  /// Don't overwrite ignored files that exist in the checkout target
  static const int GIT_CHECKOUT_DONT_OVERWRITE_IGNORED = 524288;

  /// Write normal merge files for conflicts
  static const int GIT_CHECKOUT_CONFLICT_STYLE_MERGE = 1048576;

  /// Include common ancestor data in diff3 format files for conflicts
  static const int GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 = 2097152;

  /// Don't overwrite existing files or folders
  static const int GIT_CHECKOUT_DONT_REMOVE_EXISTING = 4194304;

  /// Normally checkout writes the index upon completion; this prevents that.
  static const int GIT_CHECKOUT_DONT_WRITE_INDEX = 8388608;

  /// Recursively checkout submodules with same options (NOT IMPLEMENTED)
  static const int GIT_CHECKOUT_UPDATE_SUBMODULES = 65536;

  /// Recursively checkout submodules if HEAD moved in super repo (NOT IMPLEMENTED)
  static const int GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED = 131072;
}

/// Checkout performance-reporting structure
class git_checkout_perfdata extends ffi.Opaque {}

/// Checkout options structure
///
/// Initialize with `GIT_CHECKOUT_OPTIONS_INIT`. Alternatively, you can
/// use `git_checkout_options_init`.
class git_checkout_options extends ffi.Struct {
  /// < The version
  @ffi.Uint32()
  external int version;

  /// < default will be a safe checkout
  @ffi.Uint32()
  external int checkout_strategy;

  /// < don't apply filters like CRLF conversion
  @ffi.Int32()
  external int disable_filters;

  /// < default is 0755
  @ffi.Uint32()
  external int dir_mode;

  /// < default is 0644 or 0755 as dictated by blob
  @ffi.Uint32()
  external int file_mode;

  /// < default is O_CREAT | O_TRUNC | O_WRONLY
  @ffi.Int32()
  external int file_open_flags;

  /// < see `git_checkout_notify_t` above
  @ffi.Uint32()
  external int notify_flags;

  /// Optional callback to get notifications on specific file states.
  /// @see git_checkout_notify_t
  external ffi.Pointer<ffi.NativeFunction<git_checkout_notify_cb>> notify_cb;

  /// Payload passed to notify_cb
  external ffi.Pointer<ffi.Void> notify_payload;

  /// Optional callback to notify the consumer of checkout progress.
  external ffi.Pointer<ffi.NativeFunction<git_checkout_progress_cb>>
      progress_cb;

  /// Payload passed to progress_cb
  external ffi.Pointer<ffi.Void> progress_payload;

  /// A list of wildmatch patterns or paths.
  ///
  /// By default, all paths are processed. If you pass an array of wildmatch
  /// patterns, those will be used to filter which paths should be taken into
  /// account.
  ///
  /// Use GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH to treat as a simple list.
  external git_strarray paths;

  /// The expected content of the working directory; defaults to HEAD.
  ///
  /// If the working directory does not match this baseline information,
  /// that will produce a checkout conflict.
  external ffi.Pointer<git_tree> baseline;

  /// Like `baseline` above, though expressed as an index.  This
  /// option overrides `baseline`.
  external ffi.Pointer<git_index> baseline_index;

  /// < alternative checkout path to workdir
  external ffi.Pointer<ffi.Int8> target_directory;

  /// < the name of the common ancestor side of conflicts
  external ffi.Pointer<ffi.Int8> ancestor_label;

  /// < the name of the "our" side of conflicts
  external ffi.Pointer<ffi.Int8> our_label;

  /// < the name of the "their" side of conflicts
  external ffi.Pointer<ffi.Int8> their_label;

  /// Optional callback to notify the consumer of performance data.
  external ffi.Pointer<ffi.NativeFunction<git_checkout_perfdata_cb>>
      perfdata_cb;

  /// Payload passed to perfdata_cb
  external ffi.Pointer<ffi.Void> perfdata_payload;
}

class git_object extends ffi.Opaque {}

/// Pluggable similarity metric
class git_diff_similarity_metric extends ffi.Opaque {}

/// Merging options
class git_merge_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// See `git_merge_flag_t` above
  @ffi.Uint32()
  external int flags;

  /// Similarity to consider a file renamed (default 50).  If
  /// `GIT_MERGE_FIND_RENAMES` is enabled, added files will be compared
  /// with deleted files to determine their similarity.  Files that are
  /// more similar than the rename threshold (percentage-wise) will be
  /// treated as a rename.
  @ffi.Uint32()
  external int rename_threshold;

  /// Maximum similarity sources to examine for renames (default 200).
  /// If the number of rename candidates (add / delete pairs) is greater
  /// than this value, inexact rename detection is aborted.
  ///
  /// This setting overrides the `merge.renameLimit` configuration value.
  @ffi.Uint32()
  external int target_limit;

  /// Pluggable similarity metric; pass NULL to use internal metric
  external ffi.Pointer<git_diff_similarity_metric> metric;

  /// Maximum number of times to merge common ancestors to build a
  /// virtual merge base when faced with criss-cross merges.  When this
  /// limit is reached, the next ancestor will simply be used instead of
  /// attempting to merge it.  The default is unlimited.
  @ffi.Uint32()
  external int recursion_limit;

  /// Default merge driver to be used when both sides of a merge have
  /// changed.  The default is the `text` driver.
  external ffi.Pointer<ffi.Int8> default_driver;

  /// Flags for handling conflicting content, to be used with the standard
  /// (`text`) merge driver.
  @ffi.Int32()
  external int file_favor;

  /// see `git_merge_file_flag_t` above
  @ffi.Uint32()
  external int file_flags;
}

/// Options for connecting through a proxy
///
/// Note that not all types may be supported, depending on the platform
/// and compilation options.
class git_proxy_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// The type of proxy to use, by URL, auto-detect.
  @ffi.Int32()
  external int type;

  /// The URL of the proxy.
  external ffi.Pointer<ffi.Int8> url;

  /// This will be called if the remote host requires
  /// authentication in order to connect to it.
  ///
  /// Returning GIT_PASSTHROUGH will make libgit2 behave as
  /// though this field isn't set.
  external ffi.Pointer<ffi.NativeFunction<git_credential_acquire_cb>>
      credentials;

  /// If cert verification fails, this will be called to let the
  /// user make the final decision of whether to allow the
  /// connection to proceed. Returns 0 to allow the connection
  /// or a negative value to indicate an error.
  external ffi.Pointer<ffi.NativeFunction<git_transport_certificate_check_cb>>
      certificate_check;

  /// Payload to be provided to the credentials and certificate
  /// check callbacks.
  external ffi.Pointer<ffi.Void> payload;
}

/// Fetch options structure.
///
/// Zero out for defaults.  Initialize with `GIT_FETCH_OPTIONS_INIT` macro to
/// correctly set the `version` field.  E.g.
///
/// git_fetch_options opts = GIT_FETCH_OPTIONS_INIT;
class git_fetch_options extends ffi.Struct {
  @ffi.Int32()
  external int version;

  /// Callbacks to use for this fetch operation
  external git_remote_callbacks callbacks;

  /// Whether to perform a prune after the fetch
  @ffi.Int32()
  external int prune;

  /// Whether to write the results to FETCH_HEAD. Defaults to
  /// on. Leave this default in order to behave like git.
  @ffi.Int32()
  external int update_fetchhead;

  /// Determines how to behave regarding tags on the remote, such
  /// as auto-downloading tags for objects we're downloading or
  /// downloading all of them.
  ///
  /// The default is to auto-follow tags.
  @ffi.Int32()
  external int download_tags;

  /// Proxy options to use, by default no proxy is used.
  external git_proxy_options proxy_opts;

  /// Extra headers for this fetch operation
  external git_strarray custom_headers;
}

/// Controls the behavior of a git_push object.
class git_push_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// If the transport being used to push to the remote requires the creation
  /// of a pack file, this controls the number of worker threads used by
  /// the packbuilder when creating that pack file to be sent to the remote.
  ///
  /// If set to 0, the packbuilder will auto-detect the number of threads
  /// to create. The default value is 1.
  @ffi.Uint32()
  external int pb_parallelism;

  /// Callbacks to use for this push operation
  external git_remote_callbacks callbacks;

  /// Proxy options to use, by default no proxy is used.
  external git_proxy_options proxy_opts;

  /// Extra headers for this push operation
  external git_strarray custom_headers;
}

/// Clone options structure
///
/// Initialize with `GIT_CLONE_OPTIONS_INIT`. Alternatively, you can
/// use `git_clone_options_init`.
class git_clone_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// These options are passed to the checkout step. To disable
  /// checkout, set the `checkout_strategy` to
  /// `GIT_CHECKOUT_NONE`.
  external git_checkout_options checkout_opts;

  /// Options which control the fetch, including callbacks.
  ///
  /// The callbacks are used for reporting fetch progress, and for acquiring
  /// credentials in the event they are needed.
  external git_fetch_options fetch_opts;

  /// Set to zero (false) to create a standard repo, or non-zero
  /// for a bare repo
  @ffi.Int32()
  external int bare;

  /// Whether to use a fetch or copy the object database.
  @ffi.Int32()
  external int local;

  /// The name of the branch to checkout. NULL means use the
  /// remote's default branch.
  external ffi.Pointer<ffi.Int8> checkout_branch;

  /// A callback used to create the new repository into which to
  /// clone. If NULL, the 'bare' field will be used to determine
  /// whether to create a bare repository.
  external ffi.Pointer<ffi.NativeFunction<git_repository_create_cb>>
      repository_cb;

  /// An opaque payload to pass to the git_repository creation callback.
  /// This parameter is ignored unless repository_cb is non-NULL.
  external ffi.Pointer<ffi.Void> repository_cb_payload;

  /// A callback used to create the git_remote, prior to its being
  /// used to perform the clone operation. See the documentation for
  /// git_remote_create_cb for details. This parameter may be NULL,
  /// indicating that git_clone should provide default behavior.
  external ffi.Pointer<ffi.NativeFunction<git_remote_create_cb>> remote_cb;

  /// An opaque payload to pass to the git_remote creation callback.
  /// This parameter is ignored unless remote_cb is non-NULL.
  external ffi.Pointer<ffi.Void> remote_cb_payload;
}

class git_commit extends ffi.Opaque {}

/// Structure to store extra details of the last error that occurred.
///
/// This is kept on a per-thread basis if GIT_THREADS was defined when the
/// library was build, otherwise one is kept globally for the library
class git_error extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> message;

  @ffi.Int32()
  external int klass;
}

/// Select the files on which to report status.
///
/// With `git_status_foreach_ext`, this will control which changes get
/// callbacks.  With `git_status_list_new`, these will control which
/// changes are included in the list.
///
/// - GIT_STATUS_SHOW_INDEX_AND_WORKDIR is the default.  This roughly
/// matches `git status --porcelain` regarding which files are
/// included and in what order.
/// - GIT_STATUS_SHOW_INDEX_ONLY only gives status based on HEAD to index
/// comparison, not looking at working directory changes.
/// - GIT_STATUS_SHOW_WORKDIR_ONLY only gives status based on index to
/// working directory comparison, not comparing the index to the HEAD.
abstract class git_status_show_t {
  static const int GIT_STATUS_SHOW_INDEX_AND_WORKDIR = 0;
  static const int GIT_STATUS_SHOW_INDEX_ONLY = 1;
  static const int GIT_STATUS_SHOW_WORKDIR_ONLY = 2;
}

/// Flags to control status callbacks
///
/// - GIT_STATUS_OPT_INCLUDE_UNTRACKED says that callbacks should be made
/// on untracked files.  These will only be made if the workdir files are
/// included in the status "show" option.
/// - GIT_STATUS_OPT_INCLUDE_IGNORED says that ignored files get callbacks.
/// Again, these callbacks will only be made if the workdir files are
/// included in the status "show" option.
/// - GIT_STATUS_OPT_INCLUDE_UNMODIFIED indicates that callback should be
/// made even on unmodified files.
/// - GIT_STATUS_OPT_EXCLUDE_SUBMODULES indicates that submodules should be
/// skipped.  This only applies if there are no pending typechanges to
/// the submodule (either from or to another type).
/// - GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS indicates that all files in
/// untracked directories should be included.  Normally if an entire
/// directory is new, then just the top-level directory is included (with
/// a trailing slash on the entry name).  This flag says to include all
/// of the individual files in the directory instead.
/// - GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH indicates that the given path
/// should be treated as a literal path, and not as a pathspec pattern.
/// - GIT_STATUS_OPT_RECURSE_IGNORED_DIRS indicates that the contents of
/// ignored directories should be included in the status.  This is like
/// doing `git ls-files -o -i --exclude-standard` with core git.
/// - GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX indicates that rename detection
/// should be processed between the head and the index and enables
/// the GIT_STATUS_INDEX_RENAMED as a possible status flag.
/// - GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR indicates that rename
/// detection should be run between the index and the working directory
/// and enabled GIT_STATUS_WT_RENAMED as a possible status flag.
/// - GIT_STATUS_OPT_SORT_CASE_SENSITIVELY overrides the native case
/// sensitivity for the file system and forces the output to be in
/// case-sensitive order
/// - GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY overrides the native case
/// sensitivity for the file system and forces the output to be in
/// case-insensitive order
/// - GIT_STATUS_OPT_RENAMES_FROM_REWRITES indicates that rename detection
/// should include rewritten files
/// - GIT_STATUS_OPT_NO_REFRESH bypasses the default status behavior of
/// doing a "soft" index reload (i.e. reloading the index data if the
/// file on disk has been modified outside libgit2).
/// - GIT_STATUS_OPT_UPDATE_INDEX tells libgit2 to refresh the stat cache
/// in the index for files that are unchanged but have out of date stat
/// information in the index.  It will result in less work being done on
/// subsequent calls to get status.  This is mutually exclusive with the
/// NO_REFRESH option.
///
/// Calling `git_status_foreach()` is like calling the extended version
/// with: GIT_STATUS_OPT_INCLUDE_IGNORED, GIT_STATUS_OPT_INCLUDE_UNTRACKED,
/// and GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS.  Those options are bundled
/// together as `GIT_STATUS_OPT_DEFAULTS` if you want them as a baseline.
abstract class git_status_opt_t {
  static const int GIT_STATUS_OPT_INCLUDE_UNTRACKED = 1;
  static const int GIT_STATUS_OPT_INCLUDE_IGNORED = 2;
  static const int GIT_STATUS_OPT_INCLUDE_UNMODIFIED = 4;
  static const int GIT_STATUS_OPT_EXCLUDE_SUBMODULES = 8;
  static const int GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS = 16;
  static const int GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH = 32;
  static const int GIT_STATUS_OPT_RECURSE_IGNORED_DIRS = 64;
  static const int GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX = 128;
  static const int GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR = 256;
  static const int GIT_STATUS_OPT_SORT_CASE_SENSITIVELY = 512;
  static const int GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY = 1024;
  static const int GIT_STATUS_OPT_RENAMES_FROM_REWRITES = 2048;
  static const int GIT_STATUS_OPT_NO_REFRESH = 4096;
  static const int GIT_STATUS_OPT_UPDATE_INDEX = 8192;
  static const int GIT_STATUS_OPT_INCLUDE_UNREADABLE = 16384;
  static const int GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED = 32768;
}

/// Options to control how `git_status_foreach_ext()` will issue callbacks.
///
/// Initialize with `GIT_STATUS_OPTIONS_INIT`. Alternatively, you can
/// use `git_status_options_init`.
class git_status_options extends ffi.Struct {
  /// < The version
  @ffi.Uint32()
  external int version;

  /// The `show` value is one of the `git_status_show_t` constants that
  /// control which files to scan and in what order.
  @ffi.Int32()
  external int show_1;

  /// The `flags` value is an OR'ed combination of the `git_status_opt_t`
  /// values above.
  @ffi.Uint32()
  external int flags;

  /// The `pathspec` is an array of path patterns to match (using
  /// fnmatch-style matching), or just an array of paths to match exactly if
  /// `GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH` is specified in the flags.
  external git_strarray pathspec;

  /// The `baseline` is the tree to be used for comparison to the working directory
  /// and index; defaults to HEAD.
  external ffi.Pointer<git_tree> baseline;
}

/// A status entry, providing the differences between the file as it exists
/// in HEAD and the index, and providing the differences between the index
/// and the working directory.
///
/// The `status` value provides the status flags for this file.
///
/// The `head_to_index` value provides detailed information about the
/// differences between the file in HEAD and the file in the index.
///
/// The `index_to_workdir` value provides detailed information about the
/// differences between the file in the index and the file in the
/// working directory.
class git_status_entry extends ffi.Struct {
  @ffi.Int32()
  external int status;

  external ffi.Pointer<git_diff_delta> head_to_index;

  external ffi.Pointer<git_diff_delta> index_to_workdir;
}

class git_status_list extends ffi.Opaque {}

const int GIT_REPOSITORY_INIT_OPTIONS_VERSION = 1;

const int GIT_CHECKOUT_OPTIONS_VERSION = 1;

const int GIT_MERGE_OPTIONS_VERSION = 1;

const int GIT_FETCH_OPTIONS_VERSION = 1;

const int GIT_PUSH_OPTIONS_VERSION = 1;

const int GIT_CLONE_OPTIONS_VERSION = 1;

const int GIT_STATUS_OPTIONS_VERSION = 1;

typedef _c_libgit2_features = ffi.Int32 Function();

typedef _dart_libgit2_features = int Function();

typedef _c_buf_dispose = ffi.Void Function(
  ffi.Pointer<git_buf> buffer,
);

typedef _dart_buf_dispose = void Function(
  ffi.Pointer<git_buf> buffer,
);

typedef _c_oid_cpy = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_oid> src,
);

typedef _dart_oid_cpy = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_oid> src,
);

typedef _c_repository_open = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_repository_open = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_repository_free = ffi.Void Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_repository_free = void Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_repository_init = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
  ffi.Uint32 is_bare,
);

typedef _dart_repository_init = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
  int is_bare,
);

typedef _c_repository_init_options_init = ffi.Int32 Function(
  ffi.Pointer<git_repository_init_options> opts,
  ffi.Uint32 version,
);

typedef _dart_repository_init_options_init = int Function(
  ffi.Pointer<git_repository_init_options> opts,
  int version,
);

typedef _c_repository_init_ext = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> repo_path,
  ffi.Pointer<git_repository_init_options> opts,
);

typedef _dart_repository_init_ext = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> repo_path,
  ffi.Pointer<git_repository_init_options> opts,
);

typedef _c_repository_head = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_repository_head = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_repository_head_unborn = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_repository_head_unborn = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_repository_index = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_repository_index = int Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_repository_state_cleanup = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_repository_state_cleanup = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef git_repository_mergehead_foreach_cb = ffi.Int32 Function(
  ffi.Pointer<git_oid>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_repository_mergehead_foreach = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_repository_mergehead_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_repository_mergehead_foreach = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_repository_mergehead_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_repository_set_head = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _dart_repository_set_head = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _c_repository_state = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_repository_state = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_annotated_commit_from_ref = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_reference> ref,
);

typedef _dart_annotated_commit_from_ref = int Function(
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_reference> ref,
);

typedef _c_annotated_commit_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_annotated_commit> commit,
);

typedef _dart_annotated_commit_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_annotated_commit> commit,
);

typedef _c_annotated_commit_free = ffi.Void Function(
  ffi.Pointer<git_annotated_commit> commit,
);

typedef _dart_annotated_commit_free = void Function(
  ffi.Pointer<git_annotated_commit> commit,
);

typedef _c_tree_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_tree>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _dart_tree_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_tree>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _c_tree_free = ffi.Void Function(
  ffi.Pointer<git_tree> tree,
);

typedef _dart_tree_free = void Function(
  ffi.Pointer<git_tree> tree,
);

typedef _c_strarray_dispose = ffi.Void Function(
  ffi.Pointer<git_strarray> array,
);

typedef _dart_strarray_dispose = void Function(
  ffi.Pointer<git_strarray> array,
);

typedef _c_reference_name_to_id = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_reference_name_to_id = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_reference_dwim = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> shorthand,
);

typedef _dart_reference_dwim = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> shorthand,
);

typedef _c_reference_target = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_reference_target = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_reference_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_reference_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_reference_resolve = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference> ref,
);

typedef _dart_reference_resolve = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference> ref,
);

typedef _c_reference_set_target = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference> ref,
  ffi.Pointer<git_oid> id,
  ffi.Pointer<ffi.Int8> log_message,
);

typedef _dart_reference_set_target = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference> ref,
  ffi.Pointer<git_oid> id,
  ffi.Pointer<ffi.Int8> log_message,
);

typedef _c_reference_free = ffi.Void Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_reference_free = void Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_branch_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> out,
  ffi.Pointer<git_reference> ref,
);

typedef _dart_branch_name = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> out,
  ffi.Pointer<git_reference> ref,
);

typedef _c_branch_upstream = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference> branch,
);

typedef _dart_branch_upstream = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference> branch,
);

typedef _c_checkout_options_init = ffi.Int32 Function(
  ffi.Pointer<git_checkout_options> opts,
  ffi.Uint32 version,
);

typedef _dart_checkout_options_init = int Function(
  ffi.Pointer<git_checkout_options> opts,
  int version,
);

typedef _c_checkout_head = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_checkout_options> opts,
);

typedef _dart_checkout_head = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_checkout_options> opts,
);

typedef _c_checkout_tree = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_object> treeish,
  ffi.Pointer<git_checkout_options> opts,
);

typedef _dart_checkout_tree = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_object> treeish,
  ffi.Pointer<git_checkout_options> opts,
);

typedef _c_index_free = ffi.Void Function(
  ffi.Pointer<git_index> index,
);

typedef _dart_index_free = void Function(
  ffi.Pointer<git_index> index,
);

typedef _c_index_write = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
);

typedef _dart_index_write = int Function(
  ffi.Pointer<git_index> index,
);

typedef _c_index_write_tree = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_index> index,
);

typedef _dart_index_write_tree = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_index> index,
);

typedef _c_index_add_bypath = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_index_add_bypath = int Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_index_remove_bypath = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_index_remove_bypath = int Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_merge_options_init = ffi.Int32 Function(
  ffi.Pointer<git_merge_options> opts,
  ffi.Uint32 version,
);

typedef _dart_merge_options_init = int Function(
  ffi.Pointer<git_merge_options> opts,
  int version,
);

typedef _c_merge_analysis = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> analysis_out,
  ffi.Pointer<ffi.Int32> preference_out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
  ffi.IntPtr their_heads_len,
);

typedef _dart_merge_analysis = int Function(
  ffi.Pointer<ffi.Int32> analysis_out,
  ffi.Pointer<ffi.Int32> preference_out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
  int their_heads_len,
);

typedef _c_merge = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
  ffi.IntPtr their_heads_len,
  ffi.Pointer<git_merge_options> merge_opts,
  ffi.Pointer<git_checkout_options> checkout_opts,
);

typedef _dart_merge = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
  int their_heads_len,
  ffi.Pointer<git_merge_options> merge_opts,
  ffi.Pointer<git_checkout_options> checkout_opts,
);

typedef _c_credential_userpass_plaintext_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> password,
);

typedef _dart_credential_userpass_plaintext_new = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> password,
);

typedef _c_remote_create = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> url,
);

typedef _dart_remote_create = int Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> url,
);

typedef _c_remote_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_remote_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_remote_free = ffi.Void Function(
  ffi.Pointer<git_remote> remote,
);

typedef _dart_remote_free = void Function(
  ffi.Pointer<git_remote> remote,
);

typedef _c_remote_list = ffi.Int32 Function(
  ffi.Pointer<git_strarray> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_remote_list = int Function(
  ffi.Pointer<git_strarray> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_fetch_options_init = ffi.Int32 Function(
  ffi.Pointer<git_fetch_options> opts,
  ffi.Uint32 version,
);

typedef _dart_fetch_options_init = int Function(
  ffi.Pointer<git_fetch_options> opts,
  int version,
);

typedef _c_push_options_init = ffi.Int32 Function(
  ffi.Pointer<git_push_options> opts,
  ffi.Uint32 version,
);

typedef _dart_push_options_init = int Function(
  ffi.Pointer<git_push_options> opts,
  int version,
);

typedef _c_remote_fetch = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_strarray> refspecs,
  ffi.Pointer<git_fetch_options> opts,
  ffi.Pointer<ffi.Int8> reflog_message,
);

typedef _dart_remote_fetch = int Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_strarray> refspecs,
  ffi.Pointer<git_fetch_options> opts,
  ffi.Pointer<ffi.Int8> reflog_message,
);

typedef _c_remote_push = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_strarray> refspecs,
  ffi.Pointer<git_push_options> opts,
);

typedef _dart_remote_push = int Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_strarray> refspecs,
  ffi.Pointer<git_push_options> opts,
);

typedef _c_remote_delete = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_remote_delete = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_clone_options_init = ffi.Int32 Function(
  ffi.Pointer<git_clone_options> opts,
  ffi.Uint32 version,
);

typedef _dart_clone_options_init = int Function(
  ffi.Pointer<git_clone_options> opts,
  int version,
);

typedef _c_clone = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Int8> local_path,
  ffi.Pointer<git_clone_options> options,
);

typedef _dart_clone = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Int8> local_path,
  ffi.Pointer<git_clone_options> options,
);

typedef _c_commit_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_commit>> commit,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _dart_commit_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_commit>> commit,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _c_commit_free = ffi.Void Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_commit_free = void Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_commit_create = ffi.Int32 Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> update_ref,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<ffi.Int8> message_encoding,
  ffi.Pointer<ffi.Int8> message,
  ffi.Pointer<git_tree> tree,
  ffi.IntPtr parent_count,
  ffi.Pointer<ffi.Pointer<git_commit>> parents,
);

typedef _dart_commit_create = int Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> update_ref,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<ffi.Int8> message_encoding,
  ffi.Pointer<ffi.Int8> message,
  ffi.Pointer<git_tree> tree,
  int parent_count,
  ffi.Pointer<ffi.Pointer<git_commit>> parents,
);

typedef _c_error_last = ffi.Pointer<git_error> Function();

typedef _dart_error_last = ffi.Pointer<git_error> Function();

typedef _c_error_set_str = ffi.Int32 Function(
  ffi.Int32 error_class,
  ffi.Pointer<ffi.Int8> string,
);

typedef _dart_error_set_str = int Function(
  int error_class,
  ffi.Pointer<ffi.Int8> string,
);

typedef _c_status_options_init = ffi.Int32 Function(
  ffi.Pointer<git_status_options> opts,
  ffi.Uint32 version,
);

typedef _dart_status_options_init = int Function(
  ffi.Pointer<git_status_options> opts,
  int version,
);

typedef _c_status_list_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_status_list>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_status_options> opts,
);

typedef _dart_status_list_new = int Function(
  ffi.Pointer<ffi.Pointer<git_status_list>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_status_options> opts,
);

typedef _c_status_list_entrycount = ffi.IntPtr Function(
  ffi.Pointer<git_status_list> statuslist,
);

typedef _dart_status_list_entrycount = int Function(
  ffi.Pointer<git_status_list> statuslist,
);

typedef _c_status_byindex = ffi.Pointer<git_status_entry> Function(
  ffi.Pointer<git_status_list> statuslist,
  ffi.IntPtr idx,
);

typedef _dart_status_byindex = ffi.Pointer<git_status_entry> Function(
  ffi.Pointer<git_status_list> statuslist,
  int idx,
);

typedef _c_status_list_free = ffi.Void Function(
  ffi.Pointer<git_status_list> statuslist,
);

typedef _dart_status_list_free = void Function(
  ffi.Pointer<git_status_list> statuslist,
);

typedef _c_libgit2_init = ffi.Int32 Function();

typedef _dart_libgit2_init = int Function();

typedef _c_libgit2_shutdown = ffi.Int32 Function();

typedef _dart_libgit2_shutdown = int Function();

typedef _c_graph_ahead_behind = ffi.Int32 Function(
  ffi.Pointer<ffi.IntPtr> ahead,
  ffi.Pointer<ffi.IntPtr> behind,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> local,
  ffi.Pointer<git_oid> upstream,
);

typedef _dart_graph_ahead_behind = int Function(
  ffi.Pointer<ffi.IntPtr> ahead,
  ffi.Pointer<ffi.IntPtr> behind,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> local,
  ffi.Pointer<git_oid> upstream,
);

typedef _c_signature_now = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_signature>> out,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> email,
);

typedef _dart_signature_now = int Function(
  ffi.Pointer<ffi.Pointer<git_signature>> out,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> email,
);

typedef _c_signature_free = ffi.Void Function(
  ffi.Pointer<git_signature> sig,
);

typedef _dart_signature_free = void Function(
  ffi.Pointer<git_signature> sig,
);

typedef _typedefC_3 = ffi.Void Function(
  ffi.Pointer<git_credential>,
);

typedef git_transport_message_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_1 = ffi.Int32 Function(
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef git_credential_acquire_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Uint32,
  ffi.Pointer<ffi.Void>,
);

typedef git_transport_certificate_check_cb = ffi.Int32 Function(
  ffi.Pointer<git_cert>,
  ffi.Int32,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef git_indexer_progress_cb = ffi.Int32 Function(
  ffi.Pointer<git_indexer_progress>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_2 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<git_oid>,
  ffi.Pointer<git_oid>,
  ffi.Pointer<ffi.Void>,
);

typedef git_packbuilder_progress = ffi.Int32 Function(
  ffi.Int32,
  ffi.Uint32,
  ffi.Uint32,
  ffi.Pointer<ffi.Void>,
);

typedef git_push_transfer_progress_cb = ffi.Int32 Function(
  ffi.Uint32,
  ffi.Uint32,
  ffi.IntPtr,
  ffi.Pointer<ffi.Void>,
);

typedef git_push_update_reference_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef git_push_negotiation = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_push_update>>,
  ffi.IntPtr,
  ffi.Pointer<ffi.Void>,
);

typedef git_transport_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_transport>>,
  ffi.Pointer<git_remote>,
  ffi.Pointer<ffi.Void>,
);

typedef git_url_resolve_cb = ffi.Int32 Function(
  ffi.Pointer<git_buf>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef git_checkout_notify_cb = ffi.Int32 Function(
  ffi.Int32,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<git_diff_file>,
  ffi.Pointer<git_diff_file>,
  ffi.Pointer<git_diff_file>,
  ffi.Pointer<ffi.Void>,
);

typedef git_checkout_progress_cb = ffi.Void Function(
  ffi.Pointer<ffi.Int8>,
  ffi.IntPtr,
  ffi.IntPtr,
  ffi.Pointer<ffi.Void>,
);

typedef git_checkout_perfdata_cb = ffi.Void Function(
  ffi.Pointer<git_checkout_perfdata>,
  ffi.Pointer<ffi.Void>,
);

typedef git_repository_create_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef git_remote_create_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_remote>>,
  ffi.Pointer<git_repository>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);
