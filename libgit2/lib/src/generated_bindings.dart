// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for libgit2
class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Query compile time options for libgit2.
  ///
  /// @return A combination of GIT_FEATURE_* values.
  ///
  /// - GIT_FEATURE_THREADS
  /// Libgit2 was compiled with thread support. Note that thread support is
  /// still to be seen as a 'work in progress' - basic object lookups are
  /// believed to be threadsafe, but other operations may not be.
  ///
  /// - GIT_FEATURE_HTTPS
  /// Libgit2 supports the https:// protocol. This requires the openssl
  /// library to be found when compiling libgit2.
  ///
  /// - GIT_FEATURE_SSH
  /// Libgit2 supports the SSH protocol for network operations. This requires
  /// the libssh2 library to be found when compiling libgit2
  int git_libgit2_features() {
    return _git_libgit2_features();
  }

  late final _git_libgit2_features_ptr =
      _lookup<ffi.NativeFunction<_c_git_libgit2_features>>(
          'git_libgit2_features');
  late final _dart_git_libgit2_features _git_libgit2_features =
      _git_libgit2_features_ptr.asFunction<_dart_git_libgit2_features>();

  /// Open a git repository.
  ///
  /// The 'path' argument must point to either a git repository
  /// folder, or an existing work dir.
  ///
  /// The method will automatically detect if 'path' is a normal
  /// or bare repository or fail is 'path' is neither.
  ///
  /// @param out pointer to the repo which will be opened
  /// @param path the path to the repository
  /// @return 0 or an error code
  int git_repository_open(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_repository_open(
      out,
      path,
    );
  }

  late final _git_repository_open_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_open>>(
          'git_repository_open');
  late final _dart_git_repository_open _git_repository_open =
      _git_repository_open_ptr.asFunction<_dart_git_repository_open>();

  /// Free a previously allocated repository
  ///
  /// Note that after a repository is free'd, all the objects it has spawned
  /// will still exist until they are manually closed by the user
  /// with `git_object_free`, but accessing any of the attributes of
  /// an object without a backing repository will result in undefined
  /// behavior
  ///
  /// @param repo repository handle to close. If NULL nothing occurs.
  void git_repository_free(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_free(
      repo,
    );
  }

  late final _git_repository_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_free>>(
          'git_repository_free');
  late final _dart_git_repository_free _git_repository_free =
      _git_repository_free_ptr.asFunction<_dart_git_repository_free>();

  /// Creates a new Git repository in the given folder.
  ///
  /// TODO:
  /// - Reinit the repository
  ///
  /// @param out pointer to the repo which will be created or reinitialized
  /// @param path the path to the repository
  /// @param is_bare if true, a Git repository without a working directory is
  /// created at the pointed path. If false, provided path will be
  /// considered as the working directory into which the .git directory
  /// will be created.
  ///
  /// @return 0 or an error code
  int git_repository_init(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> path,
    int is_bare,
  ) {
    return _git_repository_init(
      out,
      path,
      is_bare,
    );
  }

  late final _git_repository_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_init>>(
          'git_repository_init');
  late final _dart_git_repository_init _git_repository_init =
      _git_repository_init_ptr.asFunction<_dart_git_repository_init>();

  /// Create a new Git repository in the given folder with extended controls.
  ///
  /// This will initialize a new git repository (creating the repo_path
  /// if requested by flags) and working directory as needed.  It will
  /// auto-detect the case sensitivity of the file system and if the
  /// file system supports file mode bits correctly.
  ///
  /// @param out Pointer to the repo which will be created or reinitialized.
  /// @param repo_path The path to the repository.
  /// @param opts Pointer to git_repository_init_options struct.
  /// @return 0 or an error code on failure.
  int git_repository_init_ext(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> repo_path,
    ffi.Pointer<git_repository_init_options> opts,
  ) {
    return _git_repository_init_ext(
      out,
      repo_path,
      opts,
    );
  }

  late final _git_repository_init_ext_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_init_ext>>(
          'git_repository_init_ext');
  late final _dart_git_repository_init_ext _git_repository_init_ext =
      _git_repository_init_ext_ptr.asFunction<_dart_git_repository_init_ext>();

  /// Check if the current branch is unborn
  ///
  /// An unborn branch is one named from HEAD but which doesn't exist in
  /// the refs namespace, because it doesn't have any commit to point to.
  ///
  /// @param repo Repo to test
  /// @return 1 if the current branch is unborn, 0 if it's not; error
  /// code if there was an error
  int git_repository_head_unborn(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_head_unborn(
      repo,
    );
  }

  late final _git_repository_head_unborn_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_head_unborn>>(
          'git_repository_head_unborn');
  late final _dart_git_repository_head_unborn _git_repository_head_unborn =
      _git_repository_head_unborn_ptr
          .asFunction<_dart_git_repository_head_unborn>();

  /// Remove all the metadata associated with an ongoing command like merge,
  /// revert, cherry-pick, etc.  For example: MERGE_HEAD, MERGE_MSG, etc.
  ///
  /// @param repo A repository object
  /// @return 0 on success, or error
  int git_repository_state_cleanup(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_state_cleanup(
      repo,
    );
  }

  late final _git_repository_state_cleanup_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_state_cleanup>>(
          'git_repository_state_cleanup');
  late final _dart_git_repository_state_cleanup _git_repository_state_cleanup =
      _git_repository_state_cleanup_ptr
          .asFunction<_dart_git_repository_state_cleanup>();

  /// Determines the status of a git repository - ie, whether an operation
  /// (merge, cherry-pick, etc) is in progress.
  ///
  /// @param repo Repository pointer
  /// @return The state of the repository
  int git_repository_state(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_state(
      repo,
    );
  }

  late final _git_repository_state_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_state>>(
          'git_repository_state');
  late final _dart_git_repository_state _git_repository_state =
      _git_repository_state_ptr.asFunction<_dart_git_repository_state>();

  /// Get the full name of a reference.
  ///
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param ref The reference
  /// @return the full name for the ref
  ffi.Pointer<ffi.Int8> git_reference_name(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_name(
      ref,
    );
  }

  late final _git_reference_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_name>>('git_reference_name');
  late final _dart_git_reference_name _git_reference_name =
      _git_reference_name_ptr.asFunction<_dart_git_reference_name>();

  /// Return the last `git_error` object that was generated for the
  /// current thread.
  ///
  /// The default behaviour of this function is to return NULL if no previous error has occurred.
  /// However, libgit2's error strings are not cleared aggressively, so a prior
  /// (unrelated) error may be returned. This can be avoided by only calling
  /// this function if the prior call to a libgit2 API returned an error.
  ///
  /// @return A git_error object.
  ffi.Pointer<git_error> git_error_last() {
    return _git_error_last();
  }

  late final _git_error_last_ptr =
      _lookup<ffi.NativeFunction<_c_git_error_last>>('git_error_last');
  late final _dart_git_error_last _git_error_last =
      _git_error_last_ptr.asFunction<_dart_git_error_last>();

  /// Set the error message string for this thread.
  ///
  /// This function is public so that custom ODB backends and the like can
  /// relay an error message through libgit2.  Most regular users of libgit2
  /// will never need to call this function -- actually, calling it in most
  /// circumstances (for example, calling from within a callback function)
  /// will just end up having the value overwritten by libgit2 internals.
  ///
  /// This error message is stored in thread-local storage and only applies
  /// to the particular thread that this libgit2 call is made from.
  ///
  /// @param error_class One of the `git_error_t` enum above describing the
  /// general subsystem that is responsible for the error.
  /// @param string The formatted error message to keep
  /// @return 0 on success or -1 on failure
  int git_error_set_str(
    int error_class,
    ffi.Pointer<ffi.Int8> string,
  ) {
    return _git_error_set_str(
      error_class,
      string,
    );
  }

  late final _git_error_set_str_ptr =
      _lookup<ffi.NativeFunction<_c_git_error_set_str>>('git_error_set_str');
  late final _dart_git_error_set_str _git_error_set_str =
      _git_error_set_str_ptr.asFunction<_dart_git_error_set_str>();

  /// Init the global state
  ///
  /// This function must be called before any other libgit2 function in
  /// order to set up global state and threading.
  ///
  /// This function may be called multiple times - it will return the number
  /// of times the initialization has been called (including this one) that have
  /// not subsequently been shutdown.
  ///
  /// @return the number of initializations of the library, or an error code.
  int git_libgit2_init() {
    return _git_libgit2_init();
  }

  late final _git_libgit2_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_libgit2_init>>('git_libgit2_init');
  late final _dart_git_libgit2_init _git_libgit2_init =
      _git_libgit2_init_ptr.asFunction<_dart_git_libgit2_init>();

  /// Shutdown the global state
  ///
  /// Clean up the global state and threading context after calling it as
  /// many times as `git_libgit2_init()` was called - it will return the
  /// number of remainining initializations that have not been shutdown
  /// (after this one).
  ///
  /// @return the number of remaining initializations of the library, or an
  /// error code.
  int git_libgit2_shutdown() {
    return _git_libgit2_shutdown();
  }

  late final _git_libgit2_shutdown_ptr =
      _lookup<ffi.NativeFunction<_c_git_libgit2_shutdown>>(
          'git_libgit2_shutdown');
  late final _dart_git_libgit2_shutdown _git_libgit2_shutdown =
      _git_libgit2_shutdown_ptr.asFunction<_dart_git_libgit2_shutdown>();
}

/// A data buffer for exporting data from libgit2
///
/// Sometimes libgit2 wants to return an allocated data buffer to the
/// caller and have the caller take responsibility for freeing that memory.
/// This can be awkward if the caller does not have easy access to the same
/// allocation functions that libgit2 is using.  In those cases, libgit2
/// will fill in a `git_buf` and the caller can use `git_buf_dispose()` to
/// release it when they are done.
///
/// A `git_buf` may also be used for the caller to pass in a reference to
/// a block of memory they hold.  In this case, libgit2 will not resize or
/// free the memory, but will read from it as needed.
///
/// Some APIs may occasionally do something slightly unusual with a buffer,
/// such as setting `ptr` to a value that was passed in by the user.  In
/// those cases, the behavior will be clearly documented by the API.
class git_buf extends ffi.Struct {
  /// The buffer contents.
  ///
  /// `ptr` points to the start of the allocated memory.  If it is NULL,
  /// then the `git_buf` is considered empty and libgit2 will feel free
  /// to overwrite it with new data.
  external ffi.Pointer<ffi.Int8> ptr;

  /// `asize` holds the known total amount of allocated memory if the `ptr`
  /// was allocated by libgit2.  It may be larger than `size`.  If `ptr`
  /// was not allocated by libgit2 and should not be resized and/or freed,
  /// then `asize` will be set to zero.
  @ffi.IntPtr()
  external int asize;

  /// `size` holds the size (in bytes) of the data that is actually used.
  @ffi.IntPtr()
  external int size;
}

/// Unique identity of any object (commit, tree, blob, tag).
class git_oid extends ffi.Struct {
  @ffi.Array.multi([20])
  external ffi.Array<ffi.Uint8> id;
}

/// Time in a signature
class git_time extends ffi.Struct {
  /// < time in seconds from epoch
  @ffi.Int64()
  external int time;

  /// < timezone offset, in minutes
  @ffi.Int32()
  external int offset;

  /// < indicator for questionable '-0000' offsets in signature
  @ffi.Int8()
  external int sign;
}

/// An action signature (e.g. for committers, taggers, etc)
class git_signature extends ffi.Struct {
  /// < full name of the author
  external ffi.Pointer<ffi.Int8> name;

  /// < email of the author
  external ffi.Pointer<ffi.Int8> email;

  /// < time when the action happened
  external git_time when;
}

/// The base structure for all credential types
class git_credential extends ffi.Struct {
  /// < A type of credential
  @ffi.Int32()
  external int credtype;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_3>> free;
}

/// Parent type for `git_cert_hostkey` and `git_cert_x509`.
class git_cert extends ffi.Struct {
  /// Type of certificate. A `GIT_CERT_` value.
  @ffi.Int32()
  external int cert_type;
}

/// This structure is used to provide callers information about the
/// progress of indexing a packfile, either directly or part of a
/// fetch or clone that downloads a packfile.
class git_indexer_progress extends ffi.Struct {
  /// number of objects in the packfile being indexed
  @ffi.Uint32()
  external int total_objects;

  /// received objects that have been hashed
  @ffi.Uint32()
  external int indexed_objects;

  /// received_objects: objects which have been downloaded
  @ffi.Uint32()
  external int received_objects;

  /// locally-available objects that have been injected in order
  /// to fix a thin pack
  @ffi.Uint32()
  external int local_objects;

  /// number of deltas in the packfile being indexed
  @ffi.Uint32()
  external int total_deltas;

  /// received deltas that have been indexed
  @ffi.Uint32()
  external int indexed_deltas;

  /// size of the packfile received up to now
  @ffi.IntPtr()
  external int received_bytes;
}

/// Represents an update which will be performed on the remote during push
class git_push_update extends ffi.Struct {
  /// The source name of the reference
  external ffi.Pointer<ffi.Int8> src_refname;

  /// The name of the reference to update on the server
  external ffi.Pointer<ffi.Int8> dst_refname;

  /// The current target of the reference
  external git_oid src;

  /// The new target for the reference
  external git_oid dst;
}

class git_transport extends ffi.Opaque {}

class git_remote extends ffi.Opaque {}

/// The callback settings structure
///
/// Set the callbacks to be called by the remote when informing the user
/// about the progress of the network operations.
class git_remote_callbacks extends ffi.Struct {
  /// < The version
  @ffi.Uint32()
  external int version;

  /// Textual progress from the remote. Text send over the
  /// progress side-band will be passed to this function (this is
  /// the 'counting objects' output).
  external ffi.Pointer<ffi.NativeFunction<git_transport_message_cb>>
      sideband_progress;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_1>> completion;

  /// This will be called if the remote host requires
  /// authentication in order to connect to it.
  ///
  /// Returning GIT_PASSTHROUGH will make libgit2 behave as
  /// though this field isn't set.
  external ffi.Pointer<ffi.NativeFunction<git_credential_acquire_cb>>
      credentials;

  /// If cert verification fails, this will be called to let the
  /// user make the final decision of whether to allow the
  /// connection to proceed. Returns 0 to allow the connection
  /// or a negative value to indicate an error.
  external ffi.Pointer<ffi.NativeFunction<git_transport_certificate_check_cb>>
      certificate_check;

  /// During the download of new data, this will be regularly
  /// called with the current count of progress done by the
  /// indexer.
  external ffi.Pointer<ffi.NativeFunction<git_indexer_progress_cb>>
      transfer_progress;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_2>> update_tips;

  /// Function to call with progress information during pack
  /// building. Be aware that this is called inline with pack
  /// building operations, so performance may be affected.
  external ffi.Pointer<ffi.NativeFunction<git_packbuilder_progress>>
      pack_progress;

  /// Function to call with progress information during the
  /// upload portion of a push. Be aware that this is called
  /// inline with pack building operations, so performance may be
  /// affected.
  external ffi.Pointer<ffi.NativeFunction<git_push_transfer_progress_cb>>
      push_transfer_progress;

  /// See documentation of git_push_update_reference_cb
  external ffi.Pointer<ffi.NativeFunction<git_push_update_reference_cb>>
      push_update_reference;

  /// Called once between the negotiation step and the upload. It
  /// provides information about what updates will be performed.
  external ffi.Pointer<ffi.NativeFunction<git_push_negotiation>>
      push_negotiation;

  /// Create the transport to use for this operation. Leave NULL
  /// to auto-detect.
  external ffi.Pointer<ffi.NativeFunction<git_transport_cb>> transport;

  /// This will be passed to each of the callbacks in this struct
  /// as the last parameter.
  external ffi.Pointer<ffi.Void> payload;

  /// Resolve URL before connecting to remote.
  /// The returned URL will be used to connect to the remote instead.
  external ffi.Pointer<ffi.NativeFunction<git_url_resolve_cb>> resolve_url;
}

class git_repository extends ffi.Opaque {}

/// Extended options structure for `git_repository_init_ext`.
///
/// This contains extra options for `git_repository_init_ext` that enable
/// additional initialization features.  The fields are:
///
/// * flags - Combination of GIT_REPOSITORY_INIT flags above.
/// * mode  - Set to one of the standard GIT_REPOSITORY_INIT_SHARED_...
/// constants above, or to a custom value that you would like.
/// * workdir_path - The path to the working dir or NULL for default (i.e.
/// repo_path parent on non-bare repos).  IF THIS IS RELATIVE PATH,
/// IT WILL BE EVALUATED RELATIVE TO THE REPO_PATH.  If this is not
/// the "natural" working directory, a .git gitlink file will be
/// created here linking to the repo_path.
/// * description - If set, this will be used to initialize the "description"
/// file in the repository, instead of using the template content.
/// * template_path - When GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE is set,
/// this contains the path to use for the template directory.  If
/// this is NULL, the config or default directory options will be
/// used instead.
/// * initial_head - The name of the head to point HEAD at.  If NULL, then
/// this will be treated as "master" and the HEAD ref will be set
/// to "refs/heads/master".  If this begins with "refs/" it will be
/// used verbatim; otherwise "refs/heads/" will be prefixed.
/// * origin_url - If this is non-NULL, then after the rest of the
/// repository initialization is completed, an "origin" remote
/// will be added pointing to this URL.
class git_repository_init_options extends ffi.Opaque {}

/// Array of strings
class git_strarray extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<ffi.Int8>> strings;

  @ffi.IntPtr()
  external int count;
}

class git_reference extends ffi.Opaque {}

/// Description of one side of a delta.
///
/// Although this is called a "file", it could represent a file, a symbolic
/// link, a submodule commit id, or even a tree (although that only if you
/// are tracking type changes or ignored/untracked directories).
///
/// The `id` is the `git_oid` of the item.  If the entry represents an
/// absent side of a diff (e.g. the `old_file` of a `GIT_DELTA_ADDED` delta),
/// then the oid will be zeroes.
///
/// `path` is the NUL-terminated path to the entry relative to the working
/// directory of the repository.
///
/// `size` is the size of the entry in bytes.
///
/// `flags` is a combination of the `git_diff_flag_t` types
///
/// `mode` is, roughly, the stat() `st_mode` value for the item.  This will
/// be restricted to one of the `git_filemode_t` values.
///
/// The `id_abbrev` represents the known length of the `id` field, when
/// converted to a hex string.  It is generally `GIT_OID_HEXSZ`, unless this
/// delta was created from reading a patch file, in which case it may be
/// abbreviated to something reasonable, like 7 characters.
class git_diff_file extends ffi.Struct {
  external git_oid id;

  external ffi.Pointer<ffi.Int8> path;

  @ffi.Uint64()
  external int size;

  @ffi.Uint32()
  external int flags;

  @ffi.Uint16()
  external int mode;

  @ffi.Uint16()
  external int id_abbrev;
}

/// Description of changes to one entry.
///
/// A `delta` is a file pair with an old and new revision.  The old version
/// may be absent if the file was just created and the new version may be
/// absent if the file was deleted.  A diff is mostly just a list of deltas.
///
/// When iterating over a diff, this will be passed to most callbacks and
/// you can use the contents to understand exactly what has changed.
///
/// The `old_file` represents the "from" side of the diff and the `new_file`
/// represents to "to" side of the diff.  What those means depend on the
/// function that was used to generate the diff and will be documented below.
/// You can also use the `GIT_DIFF_REVERSE` flag to flip it around.
///
/// Although the two sides of the delta are named "old_file" and "new_file",
/// they actually may correspond to entries that represent a file, a symbolic
/// link, a submodule commit id, or even a tree (if you are tracking type
/// changes or ignored/untracked directories).
///
/// Under some circumstances, in the name of efficiency, not all fields will
/// be filled in, but we generally try to fill in as much as possible.  One
/// example is that the "flags" field may not have either the `BINARY` or the
/// `NOT_BINARY` flag set to avoid examining file contents if you do not pass
/// in hunk and/or line callbacks to the diff foreach iteration function.  It
/// will just use the git attributes for those files.
///
/// The similarity score is zero unless you call `git_diff_find_similar()`
/// which does a similarity analysis of files in the diff.  Use that
/// function to do rename and copy detection, and to split heavily modified
/// files in add/delete pairs.  After that call, deltas with a status of
/// GIT_DELTA_RENAMED or GIT_DELTA_COPIED will have a similarity score
/// between 0 and 100 indicating how similar the old and new sides are.
///
/// If you ask `git_diff_find_similar` to find heavily modified files to
/// break, but to not *actually* break the records, then GIT_DELTA_MODIFIED
/// records may have a non-zero similarity score if the self-similarity is
/// below the split threshold.  To display this value like core Git, invert
/// the score (a la `printf("M%03d", 100 - delta->similarity)`).
class git_diff_delta extends ffi.Struct {
  @ffi.Int32()
  external int status;

  /// < git_diff_flag_t values
  @ffi.Uint32()
  external int flags;

  /// < for RENAMED and COPIED, value 0-100
  @ffi.Uint16()
  external int similarity;

  /// < number of files in this delta
  @ffi.Uint16()
  external int nfiles;

  external git_diff_file old_file;

  external git_diff_file new_file;
}

/// Structure to store extra details of the last error that occurred.
///
/// This is kept on a per-thread basis if GIT_THREADS was defined when the
/// library was build, otherwise one is kept globally for the library
class git_error extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> message;

  @ffi.Int32()
  external int klass;
}

/// A status entry, providing the differences between the file as it exists
/// in HEAD and the index, and providing the differences between the index
/// and the working directory.
///
/// The `status` value provides the status flags for this file.
///
/// The `head_to_index` value provides detailed information about the
/// differences between the file in HEAD and the file in the index.
///
/// The `index_to_workdir` value provides detailed information about the
/// differences between the file in the index and the file in the
/// working directory.
class git_status_entry extends ffi.Struct {
  @ffi.Int32()
  external int status;

  external ffi.Pointer<git_diff_delta> head_to_index;

  external ffi.Pointer<git_diff_delta> index_to_workdir;
}

const int GIT_REPOSITORY_INIT_OPTIONS_VERSION = 1;

const int GIT_CHECKOUT_OPTIONS_VERSION = 1;

const int GIT_MERGE_OPTIONS_VERSION = 1;

const int GIT_FETCH_OPTIONS_VERSION = 1;

const int GIT_PUSH_OPTIONS_VERSION = 1;

const int GIT_CLONE_OPTIONS_VERSION = 1;

const int GIT_STATUS_OPTIONS_VERSION = 1;

typedef _c_git_libgit2_features = ffi.Int32 Function();

typedef _dart_git_libgit2_features = int Function();

typedef _c_git_repository_open = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_repository_open = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_repository_free = ffi.Void Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_free = void Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_init = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
  ffi.Uint32 is_bare,
);

typedef _dart_git_repository_init = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
  int is_bare,
);

typedef _c_git_repository_init_ext = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> repo_path,
  ffi.Pointer<git_repository_init_options> opts,
);

typedef _dart_git_repository_init_ext = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> repo_path,
  ffi.Pointer<git_repository_init_options> opts,
);

typedef _c_git_repository_head_unborn = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_head_unborn = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_state_cleanup = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_state_cleanup = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_state = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_state = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_reference_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_reference_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_error_last = ffi.Pointer<git_error> Function();

typedef _dart_git_error_last = ffi.Pointer<git_error> Function();

typedef _c_git_error_set_str = ffi.Int32 Function(
  ffi.Int32 error_class,
  ffi.Pointer<ffi.Int8> string,
);

typedef _dart_git_error_set_str = int Function(
  int error_class,
  ffi.Pointer<ffi.Int8> string,
);

typedef _c_git_libgit2_init = ffi.Int32 Function();

typedef _dart_git_libgit2_init = int Function();

typedef _c_git_libgit2_shutdown = ffi.Int32 Function();

typedef _dart_git_libgit2_shutdown = int Function();

typedef _typedefC_3 = ffi.Void Function(
  ffi.Pointer<git_credential>,
);

typedef git_transport_message_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_1 = ffi.Int32 Function(
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef git_credential_acquire_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Uint32,
  ffi.Pointer<ffi.Void>,
);

typedef git_transport_certificate_check_cb = ffi.Int32 Function(
  ffi.Pointer<git_cert>,
  ffi.Int32,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef git_indexer_progress_cb = ffi.Int32 Function(
  ffi.Pointer<git_indexer_progress>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_2 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<git_oid>,
  ffi.Pointer<git_oid>,
  ffi.Pointer<ffi.Void>,
);

typedef git_packbuilder_progress = ffi.Int32 Function(
  ffi.Int32,
  ffi.Uint32,
  ffi.Uint32,
  ffi.Pointer<ffi.Void>,
);

typedef git_push_transfer_progress_cb = ffi.Int32 Function(
  ffi.Uint32,
  ffi.Uint32,
  ffi.IntPtr,
  ffi.Pointer<ffi.Void>,
);

typedef git_push_update_reference_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef git_push_negotiation = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_push_update>>,
  ffi.IntPtr,
  ffi.Pointer<ffi.Void>,
);

typedef git_transport_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_transport>>,
  ffi.Pointer<git_remote>,
  ffi.Pointer<ffi.Void>,
);

typedef git_url_resolve_cb = ffi.Int32 Function(
  ffi.Pointer<git_buf>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);
