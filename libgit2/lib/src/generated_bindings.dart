// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings for libgit2
class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Query compile time options for libgit2.
  ///
  /// @return A combination of GIT_FEATURE_* values.
  ///
  /// - GIT_FEATURE_THREADS
  /// Libgit2 was compiled with thread support. Note that thread support is
  /// still to be seen as a 'work in progress' - basic object lookups are
  /// believed to be threadsafe, but other operations may not be.
  ///
  /// - GIT_FEATURE_HTTPS
  /// Libgit2 supports the https:// protocol. This requires the openssl
  /// library to be found when compiling libgit2.
  ///
  /// - GIT_FEATURE_SSH
  /// Libgit2 supports the SSH protocol for network operations. This requires
  /// the libssh2 library to be found when compiling libgit2
  int git_libgit2_features() {
    return _git_libgit2_features();
  }

  late final _git_libgit2_features_ptr =
      _lookup<ffi.NativeFunction<_c_git_libgit2_features>>(
          'git_libgit2_features');
  late final _dart_git_libgit2_features _git_libgit2_features =
      _git_libgit2_features_ptr.asFunction<_dart_git_libgit2_features>();

  /// Open a git repository.
  ///
  /// The 'path' argument must point to either a git repository
  /// folder, or an existing work dir.
  ///
  /// The method will automatically detect if 'path' is a normal
  /// or bare repository or fail is 'path' is neither.
  ///
  /// @param out pointer to the repo which will be opened
  /// @param path the path to the repository
  /// @return 0 or an error code
  int git_repository_open(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_repository_open(
      out,
      path,
    );
  }

  late final _git_repository_open_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_open>>(
          'git_repository_open');
  late final _dart_git_repository_open _git_repository_open =
      _git_repository_open_ptr.asFunction<_dart_git_repository_open>();

  /// Free a previously allocated repository
  ///
  /// Note that after a repository is free'd, all the objects it has spawned
  /// will still exist until they are manually closed by the user
  /// with `git_object_free`, but accessing any of the attributes of
  /// an object without a backing repository will result in undefined
  /// behavior
  ///
  /// @param repo repository handle to close. If NULL nothing occurs.
  void git_repository_free(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_free(
      repo,
    );
  }

  late final _git_repository_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_free>>(
          'git_repository_free');
  late final _dart_git_repository_free _git_repository_free =
      _git_repository_free_ptr.asFunction<_dart_git_repository_free>();

  /// Creates a new Git repository in the given folder.
  ///
  /// TODO:
  /// - Reinit the repository
  ///
  /// @param out pointer to the repo which will be created or reinitialized
  /// @param path the path to the repository
  /// @param is_bare if true, a Git repository without a working directory is
  /// created at the pointed path. If false, provided path will be
  /// considered as the working directory into which the .git directory
  /// will be created.
  ///
  /// @return 0 or an error code
  int git_repository_init(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> path,
    int is_bare,
  ) {
    return _git_repository_init(
      out,
      path,
      is_bare,
    );
  }

  late final _git_repository_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_init>>(
          'git_repository_init');
  late final _dart_git_repository_init _git_repository_init =
      _git_repository_init_ptr.asFunction<_dart_git_repository_init>();

  /// Create a new Git repository in the given folder with extended controls.
  ///
  /// This will initialize a new git repository (creating the repo_path
  /// if requested by flags) and working directory as needed.  It will
  /// auto-detect the case sensitivity of the file system and if the
  /// file system supports file mode bits correctly.
  ///
  /// @param out Pointer to the repo which will be created or reinitialized.
  /// @param repo_path The path to the repository.
  /// @param opts Pointer to git_repository_init_options struct.
  /// @return 0 or an error code on failure.
  int git_repository_init_ext(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> repo_path,
    ffi.Pointer<git_repository_init_options> opts,
  ) {
    return _git_repository_init_ext(
      out,
      repo_path,
      opts,
    );
  }

  late final _git_repository_init_ext_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_init_ext>>(
          'git_repository_init_ext');
  late final _dart_git_repository_init_ext _git_repository_init_ext =
      _git_repository_init_ext_ptr.asFunction<_dart_git_repository_init_ext>();

  /// Retrieve and resolve the reference pointed at by HEAD.
  ///
  /// The returned `git_reference` will be owned by caller and
  /// `git_reference_free()` must be called when done with it to release the
  /// allocated memory and prevent a leak.
  ///
  /// @param out pointer to the reference which will be retrieved
  /// @param repo a repository object
  ///
  /// @return 0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing
  /// branch, GIT_ENOTFOUND when HEAD is missing; an error code otherwise
  int git_repository_head(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_head(
      out,
      repo,
    );
  }

  late final _git_repository_head_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_head>>(
          'git_repository_head');
  late final _dart_git_repository_head _git_repository_head =
      _git_repository_head_ptr.asFunction<_dart_git_repository_head>();

  /// Check if the current branch is unborn
  ///
  /// An unborn branch is one named from HEAD but which doesn't exist in
  /// the refs namespace, because it doesn't have any commit to point to.
  ///
  /// @param repo Repo to test
  /// @return 1 if the current branch is unborn, 0 if it's not; error
  /// code if there was an error
  int git_repository_head_unborn(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_head_unborn(
      repo,
    );
  }

  late final _git_repository_head_unborn_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_head_unborn>>(
          'git_repository_head_unborn');
  late final _dart_git_repository_head_unborn _git_repository_head_unborn =
      _git_repository_head_unborn_ptr
          .asFunction<_dart_git_repository_head_unborn>();

  /// Get the Index file for this repository.
  ///
  /// If a custom index has not been set, the default
  /// index for the repository will be returned (the one
  /// located in `.git/index`).
  ///
  /// The index must be freed once it's no longer being used by
  /// the user.
  ///
  /// @param out Pointer to store the loaded index
  /// @param repo A repository object
  /// @return 0, or an error code
  int git_repository_index(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_index(
      out,
      repo,
    );
  }

  late final _git_repository_index_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_index>>(
          'git_repository_index');
  late final _dart_git_repository_index _git_repository_index =
      _git_repository_index_ptr.asFunction<_dart_git_repository_index>();

  /// Remove all the metadata associated with an ongoing command like merge,
  /// revert, cherry-pick, etc.  For example: MERGE_HEAD, MERGE_MSG, etc.
  ///
  /// @param repo A repository object
  /// @return 0 on success, or error
  int git_repository_state_cleanup(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_state_cleanup(
      repo,
    );
  }

  late final _git_repository_state_cleanup_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_state_cleanup>>(
          'git_repository_state_cleanup');
  late final _dart_git_repository_state_cleanup _git_repository_state_cleanup =
      _git_repository_state_cleanup_ptr
          .asFunction<_dart_git_repository_state_cleanup>();

  /// Make the repository HEAD point to the specified reference.
  ///
  /// If the provided reference points to a Tree or a Blob, the HEAD is
  /// unaltered and -1 is returned.
  ///
  /// If the provided reference points to a branch, the HEAD will point
  /// to that branch, staying attached, or become attached if it isn't yet.
  /// If the branch doesn't exist yet, no error will be return. The HEAD
  /// will then be attached to an unborn branch.
  ///
  /// Otherwise, the HEAD will be detached and will directly point to
  /// the Commit.
  ///
  /// @param repo Repository pointer
  /// @param refname Canonical name of the reference the HEAD should point at
  /// @return 0 on success, or an error code
  int git_repository_set_head(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> refname,
  ) {
    return _git_repository_set_head(
      repo,
      refname,
    );
  }

  late final _git_repository_set_head_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_set_head>>(
          'git_repository_set_head');
  late final _dart_git_repository_set_head _git_repository_set_head =
      _git_repository_set_head_ptr.asFunction<_dart_git_repository_set_head>();

  /// Determines the status of a git repository - ie, whether an operation
  /// (merge, cherry-pick, etc) is in progress.
  ///
  /// @param repo Repository pointer
  /// @return The state of the repository
  int git_repository_state(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_state(
      repo,
    );
  }

  late final _git_repository_state_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_state>>(
          'git_repository_state');
  late final _dart_git_repository_state _git_repository_state =
      _git_repository_state_ptr.asFunction<_dart_git_repository_state>();

  /// Creates a `git_annotated_commit` from the given reference.
  /// The resulting git_annotated_commit must be freed with
  /// `git_annotated_commit_free`.
  ///
  /// @param out pointer to store the git_annotated_commit result in
  /// @param repo repository that contains the given reference
  /// @param ref reference to use to lookup the git_annotated_commit
  /// @return 0 on success or error code
  int git_annotated_commit_from_ref(
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_annotated_commit_from_ref(
      out,
      repo,
      ref,
    );
  }

  late final _git_annotated_commit_from_ref_ptr =
      _lookup<ffi.NativeFunction<_c_git_annotated_commit_from_ref>>(
          'git_annotated_commit_from_ref');
  late final _dart_git_annotated_commit_from_ref
      _git_annotated_commit_from_ref = _git_annotated_commit_from_ref_ptr
          .asFunction<_dart_git_annotated_commit_from_ref>();

  /// Gets the commit ID that the given `git_annotated_commit` refers to.
  ///
  /// @param commit the given annotated commit
  /// @return commit id
  ffi.Pointer<git_oid> git_annotated_commit_id(
    ffi.Pointer<git_annotated_commit> commit,
  ) {
    return _git_annotated_commit_id(
      commit,
    );
  }

  late final _git_annotated_commit_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_annotated_commit_id>>(
          'git_annotated_commit_id');
  late final _dart_git_annotated_commit_id _git_annotated_commit_id =
      _git_annotated_commit_id_ptr.asFunction<_dart_git_annotated_commit_id>();

  /// Frees a `git_annotated_commit`.
  ///
  /// @param commit annotated commit to free
  void git_annotated_commit_free(
    ffi.Pointer<git_annotated_commit> commit,
  ) {
    return _git_annotated_commit_free(
      commit,
    );
  }

  late final _git_annotated_commit_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_annotated_commit_free>>(
          'git_annotated_commit_free');
  late final _dart_git_annotated_commit_free _git_annotated_commit_free =
      _git_annotated_commit_free_ptr
          .asFunction<_dart_git_annotated_commit_free>();

  /// Lookup a tree object from the repository.
  ///
  /// @param out Pointer to the looked up tree
  /// @param repo The repo to use when locating the tree.
  /// @param id Identity of the tree to locate.
  /// @return 0 or an error code
  int git_tree_lookup(
    ffi.Pointer<ffi.Pointer<git_tree>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_tree_lookup(
      out,
      repo,
      id,
    );
  }

  late final _git_tree_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_lookup>>('git_tree_lookup');
  late final _dart_git_tree_lookup _git_tree_lookup =
      _git_tree_lookup_ptr.asFunction<_dart_git_tree_lookup>();

  /// Free the strings contained in a string array.  This method should
  /// be called on `git_strarray` objects that were provided by the
  /// library.  Not doing so, will result in a memory leak.
  ///
  /// This does not free the `git_strarray` itself, since the library will
  /// never allocate that object directly itself.
  ///
  /// @param array The git_strarray that contains strings to free
  void git_strarray_dispose(
    ffi.Pointer<git_strarray> array,
  ) {
    return _git_strarray_dispose(
      array,
    );
  }

  late final _git_strarray_dispose_ptr =
      _lookup<ffi.NativeFunction<_c_git_strarray_dispose>>(
          'git_strarray_dispose');
  late final _dart_git_strarray_dispose _git_strarray_dispose =
      _git_strarray_dispose_ptr.asFunction<_dart_git_strarray_dispose>();

  /// Get the full name of a reference.
  ///
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param ref The reference
  /// @return the full name for the ref
  ffi.Pointer<ffi.Int8> git_reference_name(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_name(
      ref,
    );
  }

  late final _git_reference_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_name>>('git_reference_name');
  late final _dart_git_reference_name _git_reference_name =
      _git_reference_name_ptr.asFunction<_dart_git_reference_name>();

  /// Free an existing index object.
  ///
  /// @param index an existing index object
  void git_index_free(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_free(
      index,
    );
  }

  late final _git_index_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_free>>('git_index_free');
  late final _dart_git_index_free _git_index_free =
      _git_index_free_ptr.asFunction<_dart_git_index_free>();

  /// Write the index as a tree
  ///
  /// This method will scan the index and write a representation
  /// of its current state back to disk; it recursively creates
  /// tree objects for each of the subtrees stored in the index,
  /// but only returns the OID of the root tree. This is the OID
  /// that can be used e.g. to create a commit.
  ///
  /// The index instance cannot be bare, and needs to be associated
  /// to an existing repository.
  ///
  /// The index must not contain any file in conflict.
  ///
  /// @param out Pointer where to store the OID of the written tree
  /// @param index Index to write
  /// @return 0 on success, GIT_EUNMERGED when the index is not clean
  /// or an error code
  int git_index_write_tree(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_write_tree(
      out,
      index,
    );
  }

  late final _git_index_write_tree_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_write_tree>>(
          'git_index_write_tree');
  late final _dart_git_index_write_tree _git_index_write_tree =
      _git_index_write_tree_ptr.asFunction<_dart_git_index_write_tree>();

  /// Add a remote with the default fetch refspec to the repository's configuration.
  ///
  /// @param out the resulting remote
  /// @param repo the repository in which to create the remote
  /// @param name the remote's name
  /// @param url the remote's url
  /// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int git_remote_create(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> url,
  ) {
    return _git_remote_create(
      out,
      repo,
      name,
      url,
    );
  }

  late final _git_remote_create_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_create>>('git_remote_create');
  late final _dart_git_remote_create _git_remote_create =
      _git_remote_create_ptr.asFunction<_dart_git_remote_create>();

  /// Get the information for a particular remote
  ///
  /// The name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// @param out pointer to the new remote object
  /// @param repo the associated repository
  /// @param name the remote's name
  /// @return 0, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code
  int git_remote_lookup(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_remote_lookup(
      out,
      repo,
      name,
    );
  }

  late final _git_remote_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_lookup>>('git_remote_lookup');
  late final _dart_git_remote_lookup _git_remote_lookup =
      _git_remote_lookup_ptr.asFunction<_dart_git_remote_lookup>();

  /// Free the memory associated with a remote
  ///
  /// This also disconnects from the remote, if the connection
  /// has not been closed yet (using git_remote_disconnect).
  ///
  /// @param remote the remote to free
  void git_remote_free(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_free(
      remote,
    );
  }

  late final _git_remote_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_free>>('git_remote_free');
  late final _dart_git_remote_free _git_remote_free =
      _git_remote_free_ptr.asFunction<_dart_git_remote_free>();

  /// Get a list of the configured remotes for a repo
  ///
  /// The string array must be freed by the user.
  ///
  /// @param out a string array which receives the names of the remotes
  /// @param repo the repository to query
  /// @return 0 or an error code
  int git_remote_list(
    ffi.Pointer<git_strarray> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_remote_list(
      out,
      repo,
    );
  }

  late final _git_remote_list_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_list>>('git_remote_list');
  late final _dart_git_remote_list _git_remote_list =
      _git_remote_list_ptr.asFunction<_dart_git_remote_list>();

  /// Download new data and update tips
  ///
  /// Convenience function to connect to a remote, download the data,
  /// disconnect and update the remote-tracking branches.
  ///
  /// @param remote the remote to fetch from
  /// @param refspecs the refspecs to use for this fetch. Pass NULL or an
  /// empty array to use the base refspecs.
  /// @param opts options to use for this fetch
  /// @param reflog_message The message to insert into the reflogs. If NULL, the
  /// default is "fetch"
  /// @return 0 or an error code
  int git_remote_fetch(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_fetch_options> opts,
    ffi.Pointer<ffi.Int8> reflog_message,
  ) {
    return _git_remote_fetch(
      remote,
      refspecs,
      opts,
      reflog_message,
    );
  }

  late final _git_remote_fetch_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_fetch>>('git_remote_fetch');
  late final _dart_git_remote_fetch _git_remote_fetch =
      _git_remote_fetch_ptr.asFunction<_dart_git_remote_fetch>();

  /// Perform a push
  ///
  /// Peform all the steps from a push.
  ///
  /// @param remote the remote to push to
  /// @param refspecs the refspecs to use for pushing. If NULL or an empty
  /// array, the configured refspecs will be used
  /// @param opts options to use for this push
  int git_remote_push(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_push_options> opts,
  ) {
    return _git_remote_push(
      remote,
      refspecs,
      opts,
    );
  }

  late final _git_remote_push_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_push>>('git_remote_push');
  late final _dart_git_remote_push _git_remote_push =
      _git_remote_push_ptr.asFunction<_dart_git_remote_push>();

  /// Delete an existing persisted remote.
  ///
  /// All remote-tracking branches and configuration settings
  /// for the remote will be removed.
  ///
  /// @param repo the repository in which to act
  /// @param name the name of the remote to delete
  /// @return 0 on success, or an error code.
  int git_remote_delete(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_remote_delete(
      repo,
      name,
    );
  }

  late final _git_remote_delete_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_delete>>('git_remote_delete');
  late final _dart_git_remote_delete _git_remote_delete =
      _git_remote_delete_ptr.asFunction<_dart_git_remote_delete>();

  /// Lookup a commit object from a repository.
  ///
  /// The returned object should be released with `git_commit_free` when no
  /// longer needed.
  ///
  /// @param commit pointer to the looked up commit
  /// @param repo the repo to use when locating the commit.
  /// @param id identity of the commit to locate. If the object is
  /// an annotated tag it will be peeled back to the commit.
  /// @return 0 or an error code
  int git_commit_lookup(
    ffi.Pointer<ffi.Pointer<git_commit>> commit,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_commit_lookup(
      commit,
      repo,
      id,
    );
  }

  late final _git_commit_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_lookup>>('git_commit_lookup');
  late final _dart_git_commit_lookup _git_commit_lookup =
      _git_commit_lookup_ptr.asFunction<_dart_git_commit_lookup>();

  /// Close an open commit
  ///
  /// This is a wrapper around git_object_free()
  ///
  /// IMPORTANT:
  /// It *is* necessary to call this method when you stop
  /// using a commit. Failure to do so will cause a memory leak.
  ///
  /// @param commit the commit to close
  void git_commit_free(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_free(
      commit,
    );
  }

  late final _git_commit_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_free>>('git_commit_free');
  late final _dart_git_commit_free _git_commit_free =
      _git_commit_free_ptr.asFunction<_dart_git_commit_free>();

  /// Return the last `git_error` object that was generated for the
  /// current thread.
  ///
  /// The default behaviour of this function is to return NULL if no previous error has occurred.
  /// However, libgit2's error strings are not cleared aggressively, so a prior
  /// (unrelated) error may be returned. This can be avoided by only calling
  /// this function if the prior call to a libgit2 API returned an error.
  ///
  /// @return A git_error object.
  ffi.Pointer<git_error> git_error_last() {
    return _git_error_last();
  }

  late final _git_error_last_ptr =
      _lookup<ffi.NativeFunction<_c_git_error_last>>('git_error_last');
  late final _dart_git_error_last _git_error_last =
      _git_error_last_ptr.asFunction<_dart_git_error_last>();

  /// Set the error message string for this thread.
  ///
  /// This function is public so that custom ODB backends and the like can
  /// relay an error message through libgit2.  Most regular users of libgit2
  /// will never need to call this function -- actually, calling it in most
  /// circumstances (for example, calling from within a callback function)
  /// will just end up having the value overwritten by libgit2 internals.
  ///
  /// This error message is stored in thread-local storage and only applies
  /// to the particular thread that this libgit2 call is made from.
  ///
  /// @param error_class One of the `git_error_t` enum above describing the
  /// general subsystem that is responsible for the error.
  /// @param string The formatted error message to keep
  /// @return 0 on success or -1 on failure
  int git_error_set_str(
    int error_class,
    ffi.Pointer<ffi.Int8> string,
  ) {
    return _git_error_set_str(
      error_class,
      string,
    );
  }

  late final _git_error_set_str_ptr =
      _lookup<ffi.NativeFunction<_c_git_error_set_str>>('git_error_set_str');
  late final _dart_git_error_set_str _git_error_set_str =
      _git_error_set_str_ptr.asFunction<_dart_git_error_set_str>();

  /// Gather file status information and populate the `git_status_list`.
  ///
  /// Note that if a `pathspec` is given in the `git_status_options` to filter
  /// the status, then the results from rename detection (if you enable it) may
  /// not be accurate.  To do rename detection properly, this must be called
  /// with no `pathspec` so that all files can be considered.
  ///
  /// @param out Pointer to store the status results in
  /// @param repo Repository object
  /// @param opts Status options structure
  /// @return 0 on success or error code
  int git_status_list_new(
    ffi.Pointer<ffi.Pointer<git_status_list>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_status_options> opts,
  ) {
    return _git_status_list_new(
      out,
      repo,
      opts,
    );
  }

  late final _git_status_list_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_status_list_new>>(
          'git_status_list_new');
  late final _dart_git_status_list_new _git_status_list_new =
      _git_status_list_new_ptr.asFunction<_dart_git_status_list_new>();

  /// Gets the count of status entries in this list.
  ///
  /// If there are no changes in status (at least according the options given
  /// when the status list was created), this can return 0.
  ///
  /// @param statuslist Existing status list object
  /// @return the number of status entries
  int git_status_list_entrycount(
    ffi.Pointer<git_status_list> statuslist,
  ) {
    return _git_status_list_entrycount(
      statuslist,
    );
  }

  late final _git_status_list_entrycount_ptr =
      _lookup<ffi.NativeFunction<_c_git_status_list_entrycount>>(
          'git_status_list_entrycount');
  late final _dart_git_status_list_entrycount _git_status_list_entrycount =
      _git_status_list_entrycount_ptr
          .asFunction<_dart_git_status_list_entrycount>();

  /// Get a pointer to one of the entries in the status list.
  ///
  /// The entry is not modifiable and should not be freed.
  ///
  /// @param statuslist Existing status list object
  /// @param idx Position of the entry
  /// @return Pointer to the entry; NULL if out of bounds
  ffi.Pointer<git_status_entry> git_status_byindex(
    ffi.Pointer<git_status_list> statuslist,
    int idx,
  ) {
    return _git_status_byindex(
      statuslist,
      idx,
    );
  }

  late final _git_status_byindex_ptr =
      _lookup<ffi.NativeFunction<_c_git_status_byindex>>('git_status_byindex');
  late final _dart_git_status_byindex _git_status_byindex =
      _git_status_byindex_ptr.asFunction<_dart_git_status_byindex>();

  /// Free an existing status list
  ///
  /// @param statuslist Existing status list object
  void git_status_list_free(
    ffi.Pointer<git_status_list> statuslist,
  ) {
    return _git_status_list_free(
      statuslist,
    );
  }

  late final _git_status_list_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_status_list_free>>(
          'git_status_list_free');
  late final _dart_git_status_list_free _git_status_list_free =
      _git_status_list_free_ptr.asFunction<_dart_git_status_list_free>();

  /// Init the global state
  ///
  /// This function must be called before any other libgit2 function in
  /// order to set up global state and threading.
  ///
  /// This function may be called multiple times - it will return the number
  /// of times the initialization has been called (including this one) that have
  /// not subsequently been shutdown.
  ///
  /// @return the number of initializations of the library, or an error code.
  int git_libgit2_init() {
    return _git_libgit2_init();
  }

  late final _git_libgit2_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_libgit2_init>>('git_libgit2_init');
  late final _dart_git_libgit2_init _git_libgit2_init =
      _git_libgit2_init_ptr.asFunction<_dart_git_libgit2_init>();

  /// Shutdown the global state
  ///
  /// Clean up the global state and threading context after calling it as
  /// many times as `git_libgit2_init()` was called - it will return the
  /// number of remainining initializations that have not been shutdown
  /// (after this one).
  ///
  /// @return the number of remaining initializations of the library, or an
  /// error code.
  int git_libgit2_shutdown() {
    return _git_libgit2_shutdown();
  }

  late final _git_libgit2_shutdown_ptr =
      _lookup<ffi.NativeFunction<_c_git_libgit2_shutdown>>(
          'git_libgit2_shutdown');
  late final _dart_git_libgit2_shutdown _git_libgit2_shutdown =
      _git_libgit2_shutdown_ptr.asFunction<_dart_git_libgit2_shutdown>();

  /// Count the number of unique commits between two commit objects
  ///
  /// There is no need for branches containing the commits to have any
  /// upstream relationship, but it helps to think of one as a branch and
  /// the other as its upstream, the `ahead` and `behind` values will be
  /// what git would report for the branches.
  ///
  /// @param ahead number of unique from commits in `upstream`
  /// @param behind number of unique from commits in `local`
  /// @param repo the repository where the commits exist
  /// @param local the commit for local
  /// @param upstream the commit for upstream
  int git_graph_ahead_behind(
    ffi.Pointer<ffi.IntPtr> ahead,
    ffi.Pointer<ffi.IntPtr> behind,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> local,
    ffi.Pointer<git_oid> upstream,
  ) {
    return _git_graph_ahead_behind(
      ahead,
      behind,
      repo,
      local,
      upstream,
    );
  }

  late final _git_graph_ahead_behind_ptr =
      _lookup<ffi.NativeFunction<_c_git_graph_ahead_behind>>(
          'git_graph_ahead_behind');
  late final _dart_git_graph_ahead_behind _git_graph_ahead_behind =
      _git_graph_ahead_behind_ptr.asFunction<_dart_git_graph_ahead_behind>();
}

/// A data buffer for exporting data from libgit2
///
/// Sometimes libgit2 wants to return an allocated data buffer to the
/// caller and have the caller take responsibility for freeing that memory.
/// This can be awkward if the caller does not have easy access to the same
/// allocation functions that libgit2 is using.  In those cases, libgit2
/// will fill in a `git_buf` and the caller can use `git_buf_dispose()` to
/// release it when they are done.
///
/// A `git_buf` may also be used for the caller to pass in a reference to
/// a block of memory they hold.  In this case, libgit2 will not resize or
/// free the memory, but will read from it as needed.
///
/// Some APIs may occasionally do something slightly unusual with a buffer,
/// such as setting `ptr` to a value that was passed in by the user.  In
/// those cases, the behavior will be clearly documented by the API.
class git_buf extends ffi.Struct {
  /// The buffer contents.
  ///
  /// `ptr` points to the start of the allocated memory.  If it is NULL,
  /// then the `git_buf` is considered empty and libgit2 will feel free
  /// to overwrite it with new data.
  external ffi.Pointer<ffi.Int8> ptr;

  /// `asize` holds the known total amount of allocated memory if the `ptr`
  /// was allocated by libgit2.  It may be larger than `size`.  If `ptr`
  /// was not allocated by libgit2 and should not be resized and/or freed,
  /// then `asize` will be set to zero.
  @ffi.IntPtr()
  external int asize;

  /// `size` holds the size (in bytes) of the data that is actually used.
  @ffi.IntPtr()
  external int size;
}

/// Unique identity of any object (commit, tree, blob, tag).
class git_oid extends ffi.Struct {
  @ffi.Array.multi([20])
  external ffi.Array<ffi.Uint8> id;
}

/// Time in a signature
class git_time extends ffi.Struct {
  /// < time in seconds from epoch
  @ffi.Int64()
  external int time;

  /// < timezone offset, in minutes
  @ffi.Int32()
  external int offset;

  /// < indicator for questionable '-0000' offsets in signature
  @ffi.Int8()
  external int sign;
}

/// An action signature (e.g. for committers, taggers, etc)
class git_signature extends ffi.Struct {
  /// < full name of the author
  external ffi.Pointer<ffi.Int8> name;

  /// < email of the author
  external ffi.Pointer<ffi.Int8> email;

  /// < time when the action happened
  external git_time when;
}

/// The base structure for all credential types
class git_credential extends ffi.Struct {
  /// < A type of credential
  @ffi.Int32()
  external int credtype;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_3>> free;
}

/// Parent type for `git_cert_hostkey` and `git_cert_x509`.
class git_cert extends ffi.Struct {
  /// Type of certificate. A `GIT_CERT_` value.
  @ffi.Int32()
  external int cert_type;
}

/// This structure is used to provide callers information about the
/// progress of indexing a packfile, either directly or part of a
/// fetch or clone that downloads a packfile.
class git_indexer_progress extends ffi.Struct {
  /// number of objects in the packfile being indexed
  @ffi.Uint32()
  external int total_objects;

  /// received objects that have been hashed
  @ffi.Uint32()
  external int indexed_objects;

  /// received_objects: objects which have been downloaded
  @ffi.Uint32()
  external int received_objects;

  /// locally-available objects that have been injected in order
  /// to fix a thin pack
  @ffi.Uint32()
  external int local_objects;

  /// number of deltas in the packfile being indexed
  @ffi.Uint32()
  external int total_deltas;

  /// received deltas that have been indexed
  @ffi.Uint32()
  external int indexed_deltas;

  /// size of the packfile received up to now
  @ffi.IntPtr()
  external int received_bytes;
}

/// Represents an update which will be performed on the remote during push
class git_push_update extends ffi.Struct {
  /// The source name of the reference
  external ffi.Pointer<ffi.Int8> src_refname;

  /// The name of the reference to update on the server
  external ffi.Pointer<ffi.Int8> dst_refname;

  /// The current target of the reference
  external git_oid src;

  /// The new target for the reference
  external git_oid dst;
}

class git_transport extends ffi.Opaque {}

class git_remote extends ffi.Opaque {}

/// The callback settings structure
///
/// Set the callbacks to be called by the remote when informing the user
/// about the progress of the network operations.
class git_remote_callbacks extends ffi.Struct {
  /// < The version
  @ffi.Uint32()
  external int version;

  /// Textual progress from the remote. Text send over the
  /// progress side-band will be passed to this function (this is
  /// the 'counting objects' output).
  external ffi.Pointer<ffi.NativeFunction<git_transport_message_cb>>
      sideband_progress;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_1>> completion;

  /// This will be called if the remote host requires
  /// authentication in order to connect to it.
  ///
  /// Returning GIT_PASSTHROUGH will make libgit2 behave as
  /// though this field isn't set.
  external ffi.Pointer<ffi.NativeFunction<git_credential_acquire_cb>>
      credentials;

  /// If cert verification fails, this will be called to let the
  /// user make the final decision of whether to allow the
  /// connection to proceed. Returns 0 to allow the connection
  /// or a negative value to indicate an error.
  external ffi.Pointer<ffi.NativeFunction<git_transport_certificate_check_cb>>
      certificate_check;

  /// During the download of new data, this will be regularly
  /// called with the current count of progress done by the
  /// indexer.
  external ffi.Pointer<ffi.NativeFunction<git_indexer_progress_cb>>
      transfer_progress;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_2>> update_tips;

  /// Function to call with progress information during pack
  /// building. Be aware that this is called inline with pack
  /// building operations, so performance may be affected.
  external ffi.Pointer<ffi.NativeFunction<git_packbuilder_progress>>
      pack_progress;

  /// Function to call with progress information during the
  /// upload portion of a push. Be aware that this is called
  /// inline with pack building operations, so performance may be
  /// affected.
  external ffi.Pointer<ffi.NativeFunction<git_push_transfer_progress_cb>>
      push_transfer_progress;

  /// See documentation of git_push_update_reference_cb
  external ffi.Pointer<ffi.NativeFunction<git_push_update_reference_cb>>
      push_update_reference;

  /// Called once between the negotiation step and the upload. It
  /// provides information about what updates will be performed.
  external ffi.Pointer<ffi.NativeFunction<git_push_negotiation>>
      push_negotiation;

  /// Create the transport to use for this operation. Leave NULL
  /// to auto-detect.
  external ffi.Pointer<ffi.NativeFunction<git_transport_cb>> transport;

  /// This will be passed to each of the callbacks in this struct
  /// as the last parameter.
  external ffi.Pointer<ffi.Void> payload;

  /// Resolve URL before connecting to remote.
  /// The returned URL will be used to connect to the remote instead.
  external ffi.Pointer<ffi.NativeFunction<git_url_resolve_cb>> resolve_url;
}

class git_repository extends ffi.Opaque {}

/// Extended options structure for `git_repository_init_ext`.
///
/// This contains extra options for `git_repository_init_ext` that enable
/// additional initialization features.  The fields are:
///
/// * flags - Combination of GIT_REPOSITORY_INIT flags above.
/// * mode  - Set to one of the standard GIT_REPOSITORY_INIT_SHARED_...
/// constants above, or to a custom value that you would like.
/// * workdir_path - The path to the working dir or NULL for default (i.e.
/// repo_path parent on non-bare repos).  IF THIS IS RELATIVE PATH,
/// IT WILL BE EVALUATED RELATIVE TO THE REPO_PATH.  If this is not
/// the "natural" working directory, a .git gitlink file will be
/// created here linking to the repo_path.
/// * description - If set, this will be used to initialize the "description"
/// file in the repository, instead of using the template content.
/// * template_path - When GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE is set,
/// this contains the path to use for the template directory.  If
/// this is NULL, the config or default directory options will be
/// used instead.
/// * initial_head - The name of the head to point HEAD at.  If NULL, then
/// this will be treated as "master" and the HEAD ref will be set
/// to "refs/heads/master".  If this begins with "refs/" it will be
/// used verbatim; otherwise "refs/heads/" will be prefixed.
/// * origin_url - If this is non-NULL, then after the rest of the
/// repository initialization is completed, an "origin" remote
/// will be added pointing to this URL.
class git_repository_init_options extends ffi.Opaque {}

class git_reference extends ffi.Opaque {}

class git_index extends ffi.Opaque {}

class git_annotated_commit extends ffi.Opaque {}

class git_tree extends ffi.Opaque {}

/// Array of strings
class git_strarray extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<ffi.Int8>> strings;

  @ffi.IntPtr()
  external int count;
}

/// Description of one side of a delta.
///
/// Although this is called a "file", it could represent a file, a symbolic
/// link, a submodule commit id, or even a tree (although that only if you
/// are tracking type changes or ignored/untracked directories).
///
/// The `id` is the `git_oid` of the item.  If the entry represents an
/// absent side of a diff (e.g. the `old_file` of a `GIT_DELTA_ADDED` delta),
/// then the oid will be zeroes.
///
/// `path` is the NUL-terminated path to the entry relative to the working
/// directory of the repository.
///
/// `size` is the size of the entry in bytes.
///
/// `flags` is a combination of the `git_diff_flag_t` types
///
/// `mode` is, roughly, the stat() `st_mode` value for the item.  This will
/// be restricted to one of the `git_filemode_t` values.
///
/// The `id_abbrev` represents the known length of the `id` field, when
/// converted to a hex string.  It is generally `GIT_OID_HEXSZ`, unless this
/// delta was created from reading a patch file, in which case it may be
/// abbreviated to something reasonable, like 7 characters.
class git_diff_file extends ffi.Struct {
  external git_oid id;

  external ffi.Pointer<ffi.Int8> path;

  @ffi.Uint64()
  external int size;

  @ffi.Uint32()
  external int flags;

  @ffi.Uint16()
  external int mode;

  @ffi.Uint16()
  external int id_abbrev;
}

/// Description of changes to one entry.
///
/// A `delta` is a file pair with an old and new revision.  The old version
/// may be absent if the file was just created and the new version may be
/// absent if the file was deleted.  A diff is mostly just a list of deltas.
///
/// When iterating over a diff, this will be passed to most callbacks and
/// you can use the contents to understand exactly what has changed.
///
/// The `old_file` represents the "from" side of the diff and the `new_file`
/// represents to "to" side of the diff.  What those means depend on the
/// function that was used to generate the diff and will be documented below.
/// You can also use the `GIT_DIFF_REVERSE` flag to flip it around.
///
/// Although the two sides of the delta are named "old_file" and "new_file",
/// they actually may correspond to entries that represent a file, a symbolic
/// link, a submodule commit id, or even a tree (if you are tracking type
/// changes or ignored/untracked directories).
///
/// Under some circumstances, in the name of efficiency, not all fields will
/// be filled in, but we generally try to fill in as much as possible.  One
/// example is that the "flags" field may not have either the `BINARY` or the
/// `NOT_BINARY` flag set to avoid examining file contents if you do not pass
/// in hunk and/or line callbacks to the diff foreach iteration function.  It
/// will just use the git attributes for those files.
///
/// The similarity score is zero unless you call `git_diff_find_similar()`
/// which does a similarity analysis of files in the diff.  Use that
/// function to do rename and copy detection, and to split heavily modified
/// files in add/delete pairs.  After that call, deltas with a status of
/// GIT_DELTA_RENAMED or GIT_DELTA_COPIED will have a similarity score
/// between 0 and 100 indicating how similar the old and new sides are.
///
/// If you ask `git_diff_find_similar` to find heavily modified files to
/// break, but to not *actually* break the records, then GIT_DELTA_MODIFIED
/// records may have a non-zero similarity score if the self-similarity is
/// below the split threshold.  To display this value like core Git, invert
/// the score (a la `printf("M%03d", 100 - delta->similarity)`).
class git_diff_delta extends ffi.Struct {
  @ffi.Int32()
  external int status;

  /// < git_diff_flag_t values
  @ffi.Uint32()
  external int flags;

  /// < for RENAMED and COPIED, value 0-100
  @ffi.Uint16()
  external int similarity;

  /// < number of files in this delta
  @ffi.Uint16()
  external int nfiles;

  external git_diff_file old_file;

  external git_diff_file new_file;
}

/// Fetch options structure.
///
/// Zero out for defaults.  Initialize with `GIT_FETCH_OPTIONS_INIT` macro to
/// correctly set the `version` field.  E.g.
///
/// git_fetch_options opts = GIT_FETCH_OPTIONS_INIT;
class git_fetch_options extends ffi.Opaque {}

/// Controls the behavior of a git_push object.
class git_push_options extends ffi.Opaque {}

class git_commit extends ffi.Opaque {}

/// Structure to store extra details of the last error that occurred.
///
/// This is kept on a per-thread basis if GIT_THREADS was defined when the
/// library was build, otherwise one is kept globally for the library
class git_error extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> message;

  @ffi.Int32()
  external int klass;
}

/// A status entry, providing the differences between the file as it exists
/// in HEAD and the index, and providing the differences between the index
/// and the working directory.
///
/// The `status` value provides the status flags for this file.
///
/// The `head_to_index` value provides detailed information about the
/// differences between the file in HEAD and the file in the index.
///
/// The `index_to_workdir` value provides detailed information about the
/// differences between the file in the index and the file in the
/// working directory.
class git_status_entry extends ffi.Struct {
  @ffi.Int32()
  external int status;

  external ffi.Pointer<git_diff_delta> head_to_index;

  external ffi.Pointer<git_diff_delta> index_to_workdir;
}

class git_status_list extends ffi.Opaque {}

/// Options to control how `git_status_foreach_ext()` will issue callbacks.
///
/// Initialize with `GIT_STATUS_OPTIONS_INIT`. Alternatively, you can
/// use `git_status_options_init`.
class git_status_options extends ffi.Opaque {}

const int GIT_REPOSITORY_INIT_OPTIONS_VERSION = 1;

const int GIT_CHECKOUT_OPTIONS_VERSION = 1;

const int GIT_MERGE_OPTIONS_VERSION = 1;

const int GIT_FETCH_OPTIONS_VERSION = 1;

const int GIT_PUSH_OPTIONS_VERSION = 1;

const int GIT_CLONE_OPTIONS_VERSION = 1;

const int GIT_STATUS_OPTIONS_VERSION = 1;

typedef _c_git_libgit2_features = ffi.Int32 Function();

typedef _dart_git_libgit2_features = int Function();

typedef _c_git_repository_open = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_repository_open = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_repository_free = ffi.Void Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_free = void Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_init = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
  ffi.Uint32 is_bare,
);

typedef _dart_git_repository_init = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
  int is_bare,
);

typedef _c_git_repository_init_ext = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> repo_path,
  ffi.Pointer<git_repository_init_options> opts,
);

typedef _dart_git_repository_init_ext = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> repo_path,
  ffi.Pointer<git_repository_init_options> opts,
);

typedef _c_git_repository_head = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_head = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_head_unborn = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_head_unborn = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_index = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_index = int Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_state_cleanup = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_state_cleanup = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_set_head = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _dart_git_repository_set_head = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _c_git_repository_state = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_state = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_annotated_commit_from_ref = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_annotated_commit_from_ref = int Function(
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_annotated_commit_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_annotated_commit> commit,
);

typedef _dart_git_annotated_commit_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_annotated_commit> commit,
);

typedef _c_git_annotated_commit_free = ffi.Void Function(
  ffi.Pointer<git_annotated_commit> commit,
);

typedef _dart_git_annotated_commit_free = void Function(
  ffi.Pointer<git_annotated_commit> commit,
);

typedef _c_git_tree_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_tree>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_tree_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_tree>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_strarray_dispose = ffi.Void Function(
  ffi.Pointer<git_strarray> array,
);

typedef _dart_git_strarray_dispose = void Function(
  ffi.Pointer<git_strarray> array,
);

typedef _c_git_reference_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_reference_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_index_free = ffi.Void Function(
  ffi.Pointer<git_index> index,
);

typedef _dart_git_index_free = void Function(
  ffi.Pointer<git_index> index,
);

typedef _c_git_index_write_tree = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_index> index,
);

typedef _dart_git_index_write_tree = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_index> index,
);

typedef _c_git_remote_create = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> url,
);

typedef _dart_git_remote_create = int Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> url,
);

typedef _c_git_remote_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_remote_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_remote_free = ffi.Void Function(
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_free = void Function(
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_remote_list = ffi.Int32 Function(
  ffi.Pointer<git_strarray> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_remote_list = int Function(
  ffi.Pointer<git_strarray> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_remote_fetch = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_strarray> refspecs,
  ffi.Pointer<git_fetch_options> opts,
  ffi.Pointer<ffi.Int8> reflog_message,
);

typedef _dart_git_remote_fetch = int Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_strarray> refspecs,
  ffi.Pointer<git_fetch_options> opts,
  ffi.Pointer<ffi.Int8> reflog_message,
);

typedef _c_git_remote_push = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_strarray> refspecs,
  ffi.Pointer<git_push_options> opts,
);

typedef _dart_git_remote_push = int Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_strarray> refspecs,
  ffi.Pointer<git_push_options> opts,
);

typedef _c_git_remote_delete = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_remote_delete = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_commit_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_commit>> commit,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_commit_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_commit>> commit,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_commit_free = ffi.Void Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_free = void Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_error_last = ffi.Pointer<git_error> Function();

typedef _dart_git_error_last = ffi.Pointer<git_error> Function();

typedef _c_git_error_set_str = ffi.Int32 Function(
  ffi.Int32 error_class,
  ffi.Pointer<ffi.Int8> string,
);

typedef _dart_git_error_set_str = int Function(
  int error_class,
  ffi.Pointer<ffi.Int8> string,
);

typedef _c_git_status_list_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_status_list>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_status_options> opts,
);

typedef _dart_git_status_list_new = int Function(
  ffi.Pointer<ffi.Pointer<git_status_list>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_status_options> opts,
);

typedef _c_git_status_list_entrycount = ffi.IntPtr Function(
  ffi.Pointer<git_status_list> statuslist,
);

typedef _dart_git_status_list_entrycount = int Function(
  ffi.Pointer<git_status_list> statuslist,
);

typedef _c_git_status_byindex = ffi.Pointer<git_status_entry> Function(
  ffi.Pointer<git_status_list> statuslist,
  ffi.IntPtr idx,
);

typedef _dart_git_status_byindex = ffi.Pointer<git_status_entry> Function(
  ffi.Pointer<git_status_list> statuslist,
  int idx,
);

typedef _c_git_status_list_free = ffi.Void Function(
  ffi.Pointer<git_status_list> statuslist,
);

typedef _dart_git_status_list_free = void Function(
  ffi.Pointer<git_status_list> statuslist,
);

typedef _c_git_libgit2_init = ffi.Int32 Function();

typedef _dart_git_libgit2_init = int Function();

typedef _c_git_libgit2_shutdown = ffi.Int32 Function();

typedef _dart_git_libgit2_shutdown = int Function();

typedef _c_git_graph_ahead_behind = ffi.Int32 Function(
  ffi.Pointer<ffi.IntPtr> ahead,
  ffi.Pointer<ffi.IntPtr> behind,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> local,
  ffi.Pointer<git_oid> upstream,
);

typedef _dart_git_graph_ahead_behind = int Function(
  ffi.Pointer<ffi.IntPtr> ahead,
  ffi.Pointer<ffi.IntPtr> behind,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> local,
  ffi.Pointer<git_oid> upstream,
);

typedef _typedefC_3 = ffi.Void Function(
  ffi.Pointer<git_credential>,
);

typedef git_transport_message_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_1 = ffi.Int32 Function(
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef git_credential_acquire_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Uint32,
  ffi.Pointer<ffi.Void>,
);

typedef git_transport_certificate_check_cb = ffi.Int32 Function(
  ffi.Pointer<git_cert>,
  ffi.Int32,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef git_indexer_progress_cb = ffi.Int32 Function(
  ffi.Pointer<git_indexer_progress>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_2 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<git_oid>,
  ffi.Pointer<git_oid>,
  ffi.Pointer<ffi.Void>,
);

typedef git_packbuilder_progress = ffi.Int32 Function(
  ffi.Int32,
  ffi.Uint32,
  ffi.Uint32,
  ffi.Pointer<ffi.Void>,
);

typedef git_push_transfer_progress_cb = ffi.Int32 Function(
  ffi.Uint32,
  ffi.Uint32,
  ffi.IntPtr,
  ffi.Pointer<ffi.Void>,
);

typedef git_push_update_reference_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef git_push_negotiation = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_push_update>>,
  ffi.IntPtr,
  ffi.Pointer<ffi.Void>,
);

typedef git_transport_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_transport>>,
  ffi.Pointer<git_remote>,
  ffi.Pointer<ffi.Void>,
);

typedef git_url_resolve_cb = ffi.Int32 Function(
  ffi.Pointer<git_buf>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);
